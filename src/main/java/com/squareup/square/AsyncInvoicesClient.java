/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.squareup.square.core.ClientOptions;
import com.squareup.square.core.MediaTypes;
import com.squareup.square.core.ObjectMappers;
import com.squareup.square.core.QueryStringMapper;
import com.squareup.square.core.RequestOptions;
import com.squareup.square.core.SquareApiException;
import com.squareup.square.core.SquareException;
import com.squareup.square.core.SyncPagingIterable;
import com.squareup.square.types.CancelInvoiceRequest;
import com.squareup.square.types.CancelInvoiceResponse;
import com.squareup.square.types.CreateInvoiceAttachmentRequest;
import com.squareup.square.types.CreateInvoiceAttachmentResponse;
import com.squareup.square.types.CreateInvoiceRequest;
import com.squareup.square.types.CreateInvoiceResponse;
import com.squareup.square.types.DeleteInvoiceAttachmentRequest;
import com.squareup.square.types.DeleteInvoiceAttachmentResponse;
import com.squareup.square.types.DeleteInvoiceResponse;
import com.squareup.square.types.DeleteInvoicesRequest;
import com.squareup.square.types.GetInvoiceResponse;
import com.squareup.square.types.GetInvoicesRequest;
import com.squareup.square.types.Invoice;
import com.squareup.square.types.ListInvoicesRequest;
import com.squareup.square.types.ListInvoicesResponse;
import com.squareup.square.types.PublishInvoiceRequest;
import com.squareup.square.types.PublishInvoiceResponse;
import com.squareup.square.types.SearchInvoicesRequest;
import com.squareup.square.types.SearchInvoicesResponse;
import com.squareup.square.types.UpdateInvoiceRequest;
import com.squareup.square.types.UpdateInvoiceResponse;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncInvoicesClient {
    protected final ClientOptions clientOptions;

    public AsyncInvoicesClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Returns a list of invoices for a given location. The response
     * is paginated. If truncated, the response includes a <code>cursor</code> that you
     * use in a subsequent request to retrieve the next set of invoices.
     */
    public CompletableFuture<SyncPagingIterable<Invoice>> list(ListInvoicesRequest request) {
        return list(request, null);
    }

    /**
     * Returns a list of invoices for a given location. The response
     * is paginated. If truncated, the response includes a <code>cursor</code> that you
     * use in a subsequent request to retrieve the next set of invoices.
     */
    public CompletableFuture<SyncPagingIterable<Invoice>> list(
            ListInvoicesRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices");
        QueryStringMapper.addQueryParameter(httpUrl, "location_id", request.getLocationId(), false);
        if (request.getCursor().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "cursor", request.getCursor().get(), false);
        }
        if (request.getLimit().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "limit", request.getLimit().get().toString(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SyncPagingIterable<Invoice>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        ListInvoicesResponse parsedResponse =
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ListInvoicesResponse.class);
                        Optional<String> startingAfter = parsedResponse.getCursor();
                        ListInvoicesRequest nextRequest = ListInvoicesRequest.builder()
                                .from(request)
                                .cursor(startingAfter)
                                .build();
                        List<Invoice> result = parsedResponse.getInvoices().orElse(Collections.emptyList());
                        future.complete(new SyncPagingIterable<Invoice>(startingAfter.isPresent(), result, () -> {
                            try {
                                return list(nextRequest, requestOptions).get();
                            } catch (InterruptedException | ExecutionException e) {
                                throw new RuntimeException(e);
                            }
                        }));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Creates a draft <a href="entity:Invoice">invoice</a>
     * for an order created using the Orders API.
     * <p>A draft invoice remains in your account and no action is taken.
     * You must publish the invoice before Square can process it (send it to the customer's email address or charge the customer’s card on file).</p>
     */
    public CompletableFuture<CreateInvoiceResponse> create(CreateInvoiceRequest request) {
        return create(request, null);
    }

    /**
     * Creates a draft <a href="entity:Invoice">invoice</a>
     * for an order created using the Orders API.
     * <p>A draft invoice remains in your account and no action is taken.
     * You must publish the invoice before Square can process it (send it to the customer's email address or charge the customer’s card on file).</p>
     */
    public CompletableFuture<CreateInvoiceResponse> create(
            CreateInvoiceRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<CreateInvoiceResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), CreateInvoiceResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Searches for invoices from a location specified in
     * the filter. You can optionally specify customers in the filter for whom to
     * retrieve invoices. In the current implementation, you can only specify one location and
     * optionally one customer.
     * <p>The response is paginated. If truncated, the response includes a <code>cursor</code>
     * that you use in a subsequent request to retrieve the next set of invoices.</p>
     */
    public CompletableFuture<SearchInvoicesResponse> search(SearchInvoicesRequest request) {
        return search(request, null);
    }

    /**
     * Searches for invoices from a location specified in
     * the filter. You can optionally specify customers in the filter for whom to
     * retrieve invoices. In the current implementation, you can only specify one location and
     * optionally one customer.
     * <p>The response is paginated. If truncated, the response includes a <code>cursor</code>
     * that you use in a subsequent request to retrieve the next set of invoices.</p>
     */
    public CompletableFuture<SearchInvoicesResponse> search(
            SearchInvoicesRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices/search")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SearchInvoicesResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), SearchInvoicesResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Retrieves an invoice by invoice ID.
     */
    public CompletableFuture<GetInvoiceResponse> get(GetInvoicesRequest request) {
        return get(request, null);
    }

    /**
     * Retrieves an invoice by invoice ID.
     */
    public CompletableFuture<GetInvoiceResponse> get(GetInvoicesRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .addPathSegment(request.getInvoiceId())
                .build();
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<GetInvoiceResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), GetInvoiceResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Updates an invoice. This endpoint supports sparse updates, so you only need
     * to specify the fields you want to change along with the required <code>version</code> field.
     * Some restrictions apply to updating invoices. For example, you cannot change the
     * <code>order_id</code> or <code>location_id</code> field.
     */
    public CompletableFuture<UpdateInvoiceResponse> update(UpdateInvoiceRequest request) {
        return update(request, null);
    }

    /**
     * Updates an invoice. This endpoint supports sparse updates, so you only need
     * to specify the fields you want to change along with the required <code>version</code> field.
     * Some restrictions apply to updating invoices. For example, you cannot change the
     * <code>order_id</code> or <code>location_id</code> field.
     */
    public CompletableFuture<UpdateInvoiceResponse> update(
            UpdateInvoiceRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .addPathSegment(request.getInvoiceId())
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<UpdateInvoiceResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), UpdateInvoiceResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Deletes the specified invoice. When an invoice is deleted, the
     * associated order status changes to CANCELED. You can only delete a draft
     * invoice (you cannot delete a published invoice, including one that is scheduled for processing).
     */
    public CompletableFuture<DeleteInvoiceResponse> delete(DeleteInvoicesRequest request) {
        return delete(request, null);
    }

    /**
     * Deletes the specified invoice. When an invoice is deleted, the
     * associated order status changes to CANCELED. You can only delete a draft
     * invoice (you cannot delete a published invoice, including one that is scheduled for processing).
     */
    public CompletableFuture<DeleteInvoiceResponse> delete(
            DeleteInvoicesRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .addPathSegment(request.getInvoiceId());
        if (request.getVersion().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "version", request.getVersion().get().toString(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<DeleteInvoiceResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), DeleteInvoiceResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Uploads a file and attaches it to an invoice. This endpoint accepts HTTP multipart/form-data file uploads
     * with a JSON <code>request</code> part and a <code>file</code> part. The <code>file</code> part must be a <code>readable stream</code> that contains a file
     * in a supported format: GIF, JPEG, PNG, TIFF, BMP, or PDF.
     * <p>Invoices can have up to 10 attachments with a total file size of 25 MB. Attachments can be added only to invoices
     * in the <code>DRAFT</code>, <code>SCHEDULED</code>, <code>UNPAID</code>, or <code>PARTIALLY_PAID</code> state.</p>
     * <p><strong>NOTE:</strong> When testing in the Sandbox environment, the total file size is limited to 1 KB.</p>
     */
    public CompletableFuture<CreateInvoiceAttachmentResponse> createInvoiceAttachment(
            CreateInvoiceAttachmentRequest request) {
        return createInvoiceAttachment(request, null);
    }

    /**
     * Uploads a file and attaches it to an invoice. This endpoint accepts HTTP multipart/form-data file uploads
     * with a JSON <code>request</code> part and a <code>file</code> part. The <code>file</code> part must be a <code>readable stream</code> that contains a file
     * in a supported format: GIF, JPEG, PNG, TIFF, BMP, or PDF.
     * <p>Invoices can have up to 10 attachments with a total file size of 25 MB. Attachments can be added only to invoices
     * in the <code>DRAFT</code>, <code>SCHEDULED</code>, <code>UNPAID</code>, or <code>PARTIALLY_PAID</code> state.</p>
     * <p><strong>NOTE:</strong> When testing in the Sandbox environment, the total file size is limited to 1 KB.</p>
     */
    public CompletableFuture<CreateInvoiceAttachmentResponse> createInvoiceAttachment(
            CreateInvoiceAttachmentRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .addPathSegment(request.getInvoiceId())
                .addPathSegments("attachments")
                .build();
        MultipartBody.Builder body = new MultipartBody.Builder().setType(MultipartBody.FORM);
        try {
            if (request.getRequest().isPresent()) {
                body.addFormDataPart(
                        "request",
                        ObjectMappers.JSON_MAPPER.writeValueAsString(
                                request.getRequest().get()));
            }
            if (request.getImageFile().isPresent()) {
                String imageFileMimeType =
                        Files.probeContentType(request.getImageFile().get().toPath());
                MediaType imageFileMimeTypeMediaType =
                        imageFileMimeType != null ? MediaType.parse(imageFileMimeType) : null;
                body.addFormDataPart(
                        "image_file",
                        request.getImageFile().get().getName(),
                        RequestBody.create(
                                imageFileMimeTypeMediaType,
                                request.getImageFile().get()));
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl)
                .method("POST", body.build())
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<CreateInvoiceAttachmentResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), CreateInvoiceAttachmentResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Removes an attachment from an invoice and permanently deletes the file. Attachments can be removed only
     * from invoices in the <code>DRAFT</code>, <code>SCHEDULED</code>, <code>UNPAID</code>, or <code>PARTIALLY_PAID</code> state.
     */
    public CompletableFuture<DeleteInvoiceAttachmentResponse> deleteInvoiceAttachment(
            DeleteInvoiceAttachmentRequest request) {
        return deleteInvoiceAttachment(request, null);
    }

    /**
     * Removes an attachment from an invoice and permanently deletes the file. Attachments can be removed only
     * from invoices in the <code>DRAFT</code>, <code>SCHEDULED</code>, <code>UNPAID</code>, or <code>PARTIALLY_PAID</code> state.
     */
    public CompletableFuture<DeleteInvoiceAttachmentResponse> deleteInvoiceAttachment(
            DeleteInvoiceAttachmentRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .addPathSegment(request.getInvoiceId())
                .addPathSegments("attachments")
                .addPathSegment(request.getAttachmentId())
                .build();
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl)
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<DeleteInvoiceAttachmentResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), DeleteInvoiceAttachmentResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Cancels an invoice. The seller cannot collect payments for
     * the canceled invoice.
     * <p>You cannot cancel an invoice in the <code>DRAFT</code> state or in a terminal state: <code>PAID</code>, <code>REFUNDED</code>, <code>CANCELED</code>, or <code>FAILED</code>.</p>
     */
    public CompletableFuture<CancelInvoiceResponse> cancel(CancelInvoiceRequest request) {
        return cancel(request, null);
    }

    /**
     * Cancels an invoice. The seller cannot collect payments for
     * the canceled invoice.
     * <p>You cannot cancel an invoice in the <code>DRAFT</code> state or in a terminal state: <code>PAID</code>, <code>REFUNDED</code>, <code>CANCELED</code>, or <code>FAILED</code>.</p>
     */
    public CompletableFuture<CancelInvoiceResponse> cancel(
            CancelInvoiceRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .addPathSegment(request.getInvoiceId())
                .addPathSegments("cancel")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<CancelInvoiceResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), CancelInvoiceResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Publishes the specified draft invoice.
     * <p>After an invoice is published, Square
     * follows up based on the invoice configuration. For example, Square
     * sends the invoice to the customer's email address, charges the customer's card on file, or does
     * nothing. Square also makes the invoice available on a Square-hosted invoice page.</p>
     * <p>The invoice <code>status</code> also changes from <code>DRAFT</code> to a status
     * based on the invoice configuration. For example, the status changes to <code>UNPAID</code> if
     * Square emails the invoice or <code>PARTIALLY_PAID</code> if Square charges a card on file for a portion of the
     * invoice amount.</p>
     * <p>In addition to the required <code>ORDERS_WRITE</code> and <code>INVOICES_WRITE</code> permissions, <code>CUSTOMERS_READ</code>
     * and <code>PAYMENTS_WRITE</code> are required when publishing invoices configured for card-on-file payments.</p>
     */
    public CompletableFuture<PublishInvoiceResponse> publish(PublishInvoiceRequest request) {
        return publish(request, null);
    }

    /**
     * Publishes the specified draft invoice.
     * <p>After an invoice is published, Square
     * follows up based on the invoice configuration. For example, Square
     * sends the invoice to the customer's email address, charges the customer's card on file, or does
     * nothing. Square also makes the invoice available on a Square-hosted invoice page.</p>
     * <p>The invoice <code>status</code> also changes from <code>DRAFT</code> to a status
     * based on the invoice configuration. For example, the status changes to <code>UNPAID</code> if
     * Square emails the invoice or <code>PARTIALLY_PAID</code> if Square charges a card on file for a portion of the
     * invoice amount.</p>
     * <p>In addition to the required <code>ORDERS_WRITE</code> and <code>INVOICES_WRITE</code> permissions, <code>CUSTOMERS_READ</code>
     * and <code>PAYMENTS_WRITE</code> are required when publishing invoices configured for card-on-file payments.</p>
     */
    public CompletableFuture<PublishInvoiceResponse> publish(
            PublishInvoiceRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/invoices")
                .addPathSegment(request.getInvoiceId())
                .addPathSegments("publish")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PublishInvoiceResponse> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), PublishInvoiceResponse.class));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class)));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
