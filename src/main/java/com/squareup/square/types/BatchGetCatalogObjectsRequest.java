/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.squareup.square.core.Nullable;
import com.squareup.square.core.NullableNonemptyFilter;
import com.squareup.square.core.ObjectMappers;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = BatchGetCatalogObjectsRequest.Builder.class)
public final class BatchGetCatalogObjectsRequest {
    private final List<String> objectIds;

    private final Optional<Boolean> includeRelatedObjects;

    private final Optional<Long> catalogVersion;

    private final Optional<Boolean> includeDeletedObjects;

    private final Optional<Boolean> includeCategoryPathToRoot;

    private final Map<String, Object> additionalProperties;

    private BatchGetCatalogObjectsRequest(
            List<String> objectIds,
            Optional<Boolean> includeRelatedObjects,
            Optional<Long> catalogVersion,
            Optional<Boolean> includeDeletedObjects,
            Optional<Boolean> includeCategoryPathToRoot,
            Map<String, Object> additionalProperties) {
        this.objectIds = objectIds;
        this.includeRelatedObjects = includeRelatedObjects;
        this.catalogVersion = catalogVersion;
        this.includeDeletedObjects = includeDeletedObjects;
        this.includeCategoryPathToRoot = includeCategoryPathToRoot;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The IDs of the CatalogObjects to be retrieved.
     */
    @JsonProperty("object_ids")
    public List<String> getObjectIds() {
        return objectIds;
    }

    /**
     * @return If <code>true</code>, the response will include additional objects that are related to the
     * requested objects. Related objects are defined as any objects referenced by ID by the results in the <code>objects</code> field
     * of the response. These objects are put in the <code>related_objects</code> field. Setting this to <code>true</code> is
     * helpful when the objects are needed for immediate display to a user.
     * This process only goes one level deep. Objects referenced by the related objects will not be included. For example,
     * <p>if the <code>objects</code> field of the response contains a CatalogItem, its associated
     * CatalogCategory objects, CatalogTax objects, CatalogImage objects and
     * CatalogModifierLists will be returned in the <code>related_objects</code> field of the
     * response. If the <code>objects</code> field of the response contains a CatalogItemVariation,
     * its parent CatalogItem will be returned in the <code>related_objects</code> field of
     * the response.</p>
     * <p>Default value: <code>false</code></p>
     */
    @JsonIgnore
    public Optional<Boolean> getIncludeRelatedObjects() {
        if (includeRelatedObjects == null) {
            return Optional.empty();
        }
        return includeRelatedObjects;
    }

    /**
     * @return The specific version of the catalog objects to be included in the response.
     * This allows you to retrieve historical versions of objects. The specified version value is matched against
     * the <a href="entity:CatalogObject">CatalogObject</a>s' <code>version</code> attribute. If not included, results will
     * be from the current version of the catalog.
     */
    @JsonIgnore
    public Optional<Long> getCatalogVersion() {
        if (catalogVersion == null) {
            return Optional.empty();
        }
        return catalogVersion;
    }

    /**
     * @return Indicates whether to include (<code>true</code>) or not (<code>false</code>) in the response deleted objects, namely, those with the <code>is_deleted</code> attribute set to <code>true</code>.
     */
    @JsonIgnore
    public Optional<Boolean> getIncludeDeletedObjects() {
        if (includeDeletedObjects == null) {
            return Optional.empty();
        }
        return includeDeletedObjects;
    }

    /**
     * @return Specifies whether or not to include the <code>path_to_root</code> list for each returned category instance. The <code>path_to_root</code> list consists
     * of <code>CategoryPathToRootNode</code> objects and specifies the path that starts with the immediate parent category of the returned category
     * and ends with its root category. If the returned category is a top-level category, the <code>path_to_root</code> list is empty and is not returned
     * in the response payload.
     */
    @JsonIgnore
    public Optional<Boolean> getIncludeCategoryPathToRoot() {
        if (includeCategoryPathToRoot == null) {
            return Optional.empty();
        }
        return includeCategoryPathToRoot;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("include_related_objects")
    private Optional<Boolean> _getIncludeRelatedObjects() {
        return includeRelatedObjects;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("catalog_version")
    private Optional<Long> _getCatalogVersion() {
        return catalogVersion;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("include_deleted_objects")
    private Optional<Boolean> _getIncludeDeletedObjects() {
        return includeDeletedObjects;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("include_category_path_to_root")
    private Optional<Boolean> _getIncludeCategoryPathToRoot() {
        return includeCategoryPathToRoot;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof BatchGetCatalogObjectsRequest && equalTo((BatchGetCatalogObjectsRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(BatchGetCatalogObjectsRequest other) {
        return objectIds.equals(other.objectIds)
                && includeRelatedObjects.equals(other.includeRelatedObjects)
                && catalogVersion.equals(other.catalogVersion)
                && includeDeletedObjects.equals(other.includeDeletedObjects)
                && includeCategoryPathToRoot.equals(other.includeCategoryPathToRoot);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.objectIds,
                this.includeRelatedObjects,
                this.catalogVersion,
                this.includeDeletedObjects,
                this.includeCategoryPathToRoot);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private List<String> objectIds = new ArrayList<>();

        private Optional<Boolean> includeRelatedObjects = Optional.empty();

        private Optional<Long> catalogVersion = Optional.empty();

        private Optional<Boolean> includeDeletedObjects = Optional.empty();

        private Optional<Boolean> includeCategoryPathToRoot = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(BatchGetCatalogObjectsRequest other) {
            objectIds(other.getObjectIds());
            includeRelatedObjects(other.getIncludeRelatedObjects());
            catalogVersion(other.getCatalogVersion());
            includeDeletedObjects(other.getIncludeDeletedObjects());
            includeCategoryPathToRoot(other.getIncludeCategoryPathToRoot());
            return this;
        }

        @JsonSetter(value = "object_ids", nulls = Nulls.SKIP)
        public Builder objectIds(List<String> objectIds) {
            this.objectIds.clear();
            this.objectIds.addAll(objectIds);
            return this;
        }

        public Builder addObjectIds(String objectIds) {
            this.objectIds.add(objectIds);
            return this;
        }

        public Builder addAllObjectIds(List<String> objectIds) {
            this.objectIds.addAll(objectIds);
            return this;
        }

        @JsonSetter(value = "include_related_objects", nulls = Nulls.SKIP)
        public Builder includeRelatedObjects(Optional<Boolean> includeRelatedObjects) {
            this.includeRelatedObjects = includeRelatedObjects;
            return this;
        }

        public Builder includeRelatedObjects(Boolean includeRelatedObjects) {
            this.includeRelatedObjects = Optional.ofNullable(includeRelatedObjects);
            return this;
        }

        public Builder includeRelatedObjects(Nullable<Boolean> includeRelatedObjects) {
            if (includeRelatedObjects.isNull()) {
                this.includeRelatedObjects = null;
            } else if (includeRelatedObjects.isEmpty()) {
                this.includeRelatedObjects = Optional.empty();
            } else {
                this.includeRelatedObjects = Optional.of(includeRelatedObjects.get());
            }
            return this;
        }

        @JsonSetter(value = "catalog_version", nulls = Nulls.SKIP)
        public Builder catalogVersion(Optional<Long> catalogVersion) {
            this.catalogVersion = catalogVersion;
            return this;
        }

        public Builder catalogVersion(Long catalogVersion) {
            this.catalogVersion = Optional.ofNullable(catalogVersion);
            return this;
        }

        public Builder catalogVersion(Nullable<Long> catalogVersion) {
            if (catalogVersion.isNull()) {
                this.catalogVersion = null;
            } else if (catalogVersion.isEmpty()) {
                this.catalogVersion = Optional.empty();
            } else {
                this.catalogVersion = Optional.of(catalogVersion.get());
            }
            return this;
        }

        @JsonSetter(value = "include_deleted_objects", nulls = Nulls.SKIP)
        public Builder includeDeletedObjects(Optional<Boolean> includeDeletedObjects) {
            this.includeDeletedObjects = includeDeletedObjects;
            return this;
        }

        public Builder includeDeletedObjects(Boolean includeDeletedObjects) {
            this.includeDeletedObjects = Optional.ofNullable(includeDeletedObjects);
            return this;
        }

        public Builder includeDeletedObjects(Nullable<Boolean> includeDeletedObjects) {
            if (includeDeletedObjects.isNull()) {
                this.includeDeletedObjects = null;
            } else if (includeDeletedObjects.isEmpty()) {
                this.includeDeletedObjects = Optional.empty();
            } else {
                this.includeDeletedObjects = Optional.of(includeDeletedObjects.get());
            }
            return this;
        }

        @JsonSetter(value = "include_category_path_to_root", nulls = Nulls.SKIP)
        public Builder includeCategoryPathToRoot(Optional<Boolean> includeCategoryPathToRoot) {
            this.includeCategoryPathToRoot = includeCategoryPathToRoot;
            return this;
        }

        public Builder includeCategoryPathToRoot(Boolean includeCategoryPathToRoot) {
            this.includeCategoryPathToRoot = Optional.ofNullable(includeCategoryPathToRoot);
            return this;
        }

        public Builder includeCategoryPathToRoot(Nullable<Boolean> includeCategoryPathToRoot) {
            if (includeCategoryPathToRoot.isNull()) {
                this.includeCategoryPathToRoot = null;
            } else if (includeCategoryPathToRoot.isEmpty()) {
                this.includeCategoryPathToRoot = Optional.empty();
            } else {
                this.includeCategoryPathToRoot = Optional.of(includeCategoryPathToRoot.get());
            }
            return this;
        }

        public BatchGetCatalogObjectsRequest build() {
            return new BatchGetCatalogObjectsRequest(
                    objectIds,
                    includeRelatedObjects,
                    catalogVersion,
                    includeDeletedObjects,
                    includeCategoryPathToRoot,
                    additionalProperties);
        }
    }
}
