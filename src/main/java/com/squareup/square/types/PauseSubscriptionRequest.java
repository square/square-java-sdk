/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.squareup.square.core.Nullable;
import com.squareup.square.core.NullableNonemptyFilter;
import com.squareup.square.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = PauseSubscriptionRequest.Builder.class)
public final class PauseSubscriptionRequest {
    private final String subscriptionId;

    private final Optional<String> pauseEffectiveDate;

    private final Optional<Long> pauseCycleDuration;

    private final Optional<String> resumeEffectiveDate;

    private final Optional<ChangeTiming> resumeChangeTiming;

    private final Optional<String> pauseReason;

    private final Map<String, Object> additionalProperties;

    private PauseSubscriptionRequest(
            String subscriptionId,
            Optional<String> pauseEffectiveDate,
            Optional<Long> pauseCycleDuration,
            Optional<String> resumeEffectiveDate,
            Optional<ChangeTiming> resumeChangeTiming,
            Optional<String> pauseReason,
            Map<String, Object> additionalProperties) {
        this.subscriptionId = subscriptionId;
        this.pauseEffectiveDate = pauseEffectiveDate;
        this.pauseCycleDuration = pauseCycleDuration;
        this.resumeEffectiveDate = resumeEffectiveDate;
        this.resumeChangeTiming = resumeChangeTiming;
        this.pauseReason = pauseReason;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The ID of the subscription to pause.
     */
    @JsonProperty("subscription_id")
    public String getSubscriptionId() {
        return subscriptionId;
    }

    /**
     * @return The <code>YYYY-MM-DD</code>-formatted date when the scheduled <code>PAUSE</code> action takes place on the subscription.
     * <p>When this date is unspecified or falls within the current billing cycle, the subscription is paused
     * on the starting date of the next billing cycle.</p>
     */
    @JsonIgnore
    public Optional<String> getPauseEffectiveDate() {
        if (pauseEffectiveDate == null) {
            return Optional.empty();
        }
        return pauseEffectiveDate;
    }

    /**
     * @return The number of billing cycles the subscription will be paused before it is reactivated.
     * <p>When this is set, a <code>RESUME</code> action is also scheduled to take place on the subscription at
     * the end of the specified pause cycle duration. In this case, neither <code>resume_effective_date</code>
     * nor <code>resume_change_timing</code> may be specified.</p>
     */
    @JsonIgnore
    public Optional<Long> getPauseCycleDuration() {
        if (pauseCycleDuration == null) {
            return Optional.empty();
        }
        return pauseCycleDuration;
    }

    /**
     * @return The date when the subscription is reactivated by a scheduled <code>RESUME</code> action.
     * This date must be at least one billing cycle ahead of <code>pause_effective_date</code>.
     */
    @JsonIgnore
    public Optional<String> getResumeEffectiveDate() {
        if (resumeEffectiveDate == null) {
            return Optional.empty();
        }
        return resumeEffectiveDate;
    }

    /**
     * @return The timing whether the subscription is reactivated immediately or at the end of the billing cycle, relative to
     * <code>resume_effective_date</code>.
     * See <a href="#type-changetiming">ChangeTiming</a> for possible values
     */
    @JsonProperty("resume_change_timing")
    public Optional<ChangeTiming> getResumeChangeTiming() {
        return resumeChangeTiming;
    }

    /**
     * @return The user-provided reason to pause the subscription.
     */
    @JsonIgnore
    public Optional<String> getPauseReason() {
        if (pauseReason == null) {
            return Optional.empty();
        }
        return pauseReason;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("pause_effective_date")
    private Optional<String> _getPauseEffectiveDate() {
        return pauseEffectiveDate;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("pause_cycle_duration")
    private Optional<Long> _getPauseCycleDuration() {
        return pauseCycleDuration;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("resume_effective_date")
    private Optional<String> _getResumeEffectiveDate() {
        return resumeEffectiveDate;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("pause_reason")
    private Optional<String> _getPauseReason() {
        return pauseReason;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof PauseSubscriptionRequest && equalTo((PauseSubscriptionRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(PauseSubscriptionRequest other) {
        return subscriptionId.equals(other.subscriptionId)
                && pauseEffectiveDate.equals(other.pauseEffectiveDate)
                && pauseCycleDuration.equals(other.pauseCycleDuration)
                && resumeEffectiveDate.equals(other.resumeEffectiveDate)
                && resumeChangeTiming.equals(other.resumeChangeTiming)
                && pauseReason.equals(other.pauseReason);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.subscriptionId,
                this.pauseEffectiveDate,
                this.pauseCycleDuration,
                this.resumeEffectiveDate,
                this.resumeChangeTiming,
                this.pauseReason);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static SubscriptionIdStage builder() {
        return new Builder();
    }

    public interface SubscriptionIdStage {
        _FinalStage subscriptionId(@NotNull String subscriptionId);

        Builder from(PauseSubscriptionRequest other);
    }

    public interface _FinalStage {
        PauseSubscriptionRequest build();

        _FinalStage pauseEffectiveDate(Optional<String> pauseEffectiveDate);

        _FinalStage pauseEffectiveDate(String pauseEffectiveDate);

        _FinalStage pauseEffectiveDate(Nullable<String> pauseEffectiveDate);

        _FinalStage pauseCycleDuration(Optional<Long> pauseCycleDuration);

        _FinalStage pauseCycleDuration(Long pauseCycleDuration);

        _FinalStage pauseCycleDuration(Nullable<Long> pauseCycleDuration);

        _FinalStage resumeEffectiveDate(Optional<String> resumeEffectiveDate);

        _FinalStage resumeEffectiveDate(String resumeEffectiveDate);

        _FinalStage resumeEffectiveDate(Nullable<String> resumeEffectiveDate);

        _FinalStage resumeChangeTiming(Optional<ChangeTiming> resumeChangeTiming);

        _FinalStage resumeChangeTiming(ChangeTiming resumeChangeTiming);

        _FinalStage pauseReason(Optional<String> pauseReason);

        _FinalStage pauseReason(String pauseReason);

        _FinalStage pauseReason(Nullable<String> pauseReason);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements SubscriptionIdStage, _FinalStage {
        private String subscriptionId;

        private Optional<String> pauseReason = Optional.empty();

        private Optional<ChangeTiming> resumeChangeTiming = Optional.empty();

        private Optional<String> resumeEffectiveDate = Optional.empty();

        private Optional<Long> pauseCycleDuration = Optional.empty();

        private Optional<String> pauseEffectiveDate = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(PauseSubscriptionRequest other) {
            subscriptionId(other.getSubscriptionId());
            pauseEffectiveDate(other.getPauseEffectiveDate());
            pauseCycleDuration(other.getPauseCycleDuration());
            resumeEffectiveDate(other.getResumeEffectiveDate());
            resumeChangeTiming(other.getResumeChangeTiming());
            pauseReason(other.getPauseReason());
            return this;
        }

        /**
         * <p>The ID of the subscription to pause.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("subscription_id")
        public _FinalStage subscriptionId(@NotNull String subscriptionId) {
            this.subscriptionId = Objects.requireNonNull(subscriptionId, "subscriptionId must not be null");
            return this;
        }

        /**
         * <p>The user-provided reason to pause the subscription.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage pauseReason(Nullable<String> pauseReason) {
            if (pauseReason.isNull()) {
                this.pauseReason = null;
            } else if (pauseReason.isEmpty()) {
                this.pauseReason = Optional.empty();
            } else {
                this.pauseReason = Optional.of(pauseReason.get());
            }
            return this;
        }

        /**
         * <p>The user-provided reason to pause the subscription.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage pauseReason(String pauseReason) {
            this.pauseReason = Optional.ofNullable(pauseReason);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "pause_reason", nulls = Nulls.SKIP)
        public _FinalStage pauseReason(Optional<String> pauseReason) {
            this.pauseReason = pauseReason;
            return this;
        }

        /**
         * <p>The timing whether the subscription is reactivated immediately or at the end of the billing cycle, relative to
         * <code>resume_effective_date</code>.
         * See <a href="#type-changetiming">ChangeTiming</a> for possible values</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage resumeChangeTiming(ChangeTiming resumeChangeTiming) {
            this.resumeChangeTiming = Optional.ofNullable(resumeChangeTiming);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "resume_change_timing", nulls = Nulls.SKIP)
        public _FinalStage resumeChangeTiming(Optional<ChangeTiming> resumeChangeTiming) {
            this.resumeChangeTiming = resumeChangeTiming;
            return this;
        }

        /**
         * <p>The date when the subscription is reactivated by a scheduled <code>RESUME</code> action.
         * This date must be at least one billing cycle ahead of <code>pause_effective_date</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage resumeEffectiveDate(Nullable<String> resumeEffectiveDate) {
            if (resumeEffectiveDate.isNull()) {
                this.resumeEffectiveDate = null;
            } else if (resumeEffectiveDate.isEmpty()) {
                this.resumeEffectiveDate = Optional.empty();
            } else {
                this.resumeEffectiveDate = Optional.of(resumeEffectiveDate.get());
            }
            return this;
        }

        /**
         * <p>The date when the subscription is reactivated by a scheduled <code>RESUME</code> action.
         * This date must be at least one billing cycle ahead of <code>pause_effective_date</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage resumeEffectiveDate(String resumeEffectiveDate) {
            this.resumeEffectiveDate = Optional.ofNullable(resumeEffectiveDate);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "resume_effective_date", nulls = Nulls.SKIP)
        public _FinalStage resumeEffectiveDate(Optional<String> resumeEffectiveDate) {
            this.resumeEffectiveDate = resumeEffectiveDate;
            return this;
        }

        /**
         * <p>The number of billing cycles the subscription will be paused before it is reactivated.</p>
         * <p>When this is set, a <code>RESUME</code> action is also scheduled to take place on the subscription at
         * the end of the specified pause cycle duration. In this case, neither <code>resume_effective_date</code>
         * nor <code>resume_change_timing</code> may be specified.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage pauseCycleDuration(Nullable<Long> pauseCycleDuration) {
            if (pauseCycleDuration.isNull()) {
                this.pauseCycleDuration = null;
            } else if (pauseCycleDuration.isEmpty()) {
                this.pauseCycleDuration = Optional.empty();
            } else {
                this.pauseCycleDuration = Optional.of(pauseCycleDuration.get());
            }
            return this;
        }

        /**
         * <p>The number of billing cycles the subscription will be paused before it is reactivated.</p>
         * <p>When this is set, a <code>RESUME</code> action is also scheduled to take place on the subscription at
         * the end of the specified pause cycle duration. In this case, neither <code>resume_effective_date</code>
         * nor <code>resume_change_timing</code> may be specified.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage pauseCycleDuration(Long pauseCycleDuration) {
            this.pauseCycleDuration = Optional.ofNullable(pauseCycleDuration);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "pause_cycle_duration", nulls = Nulls.SKIP)
        public _FinalStage pauseCycleDuration(Optional<Long> pauseCycleDuration) {
            this.pauseCycleDuration = pauseCycleDuration;
            return this;
        }

        /**
         * <p>The <code>YYYY-MM-DD</code>-formatted date when the scheduled <code>PAUSE</code> action takes place on the subscription.</p>
         * <p>When this date is unspecified or falls within the current billing cycle, the subscription is paused
         * on the starting date of the next billing cycle.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage pauseEffectiveDate(Nullable<String> pauseEffectiveDate) {
            if (pauseEffectiveDate.isNull()) {
                this.pauseEffectiveDate = null;
            } else if (pauseEffectiveDate.isEmpty()) {
                this.pauseEffectiveDate = Optional.empty();
            } else {
                this.pauseEffectiveDate = Optional.of(pauseEffectiveDate.get());
            }
            return this;
        }

        /**
         * <p>The <code>YYYY-MM-DD</code>-formatted date when the scheduled <code>PAUSE</code> action takes place on the subscription.</p>
         * <p>When this date is unspecified or falls within the current billing cycle, the subscription is paused
         * on the starting date of the next billing cycle.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage pauseEffectiveDate(String pauseEffectiveDate) {
            this.pauseEffectiveDate = Optional.ofNullable(pauseEffectiveDate);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "pause_effective_date", nulls = Nulls.SKIP)
        public _FinalStage pauseEffectiveDate(Optional<String> pauseEffectiveDate) {
            this.pauseEffectiveDate = pauseEffectiveDate;
            return this;
        }

        @java.lang.Override
        public PauseSubscriptionRequest build() {
            return new PauseSubscriptionRequest(
                    subscriptionId,
                    pauseEffectiveDate,
                    pauseCycleDuration,
                    resumeEffectiveDate,
                    resumeChangeTiming,
                    pauseReason,
                    additionalProperties);
        }
    }
}
