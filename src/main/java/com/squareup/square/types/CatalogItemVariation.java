/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.squareup.square.core.Nullable;
import com.squareup.square.core.NullableNonemptyFilter;
import com.squareup.square.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = CatalogItemVariation.Builder.class)
public final class CatalogItemVariation {
    private final Optional<String> itemId;

    private final Optional<String> name;

    private final Optional<String> sku;

    private final Optional<String> upc;

    private final Optional<Integer> ordinal;

    private final Optional<CatalogPricingType> pricingType;

    private final Optional<Money> priceMoney;

    private final Optional<List<ItemVariationLocationOverrides>> locationOverrides;

    private final Optional<Boolean> trackInventory;

    private final Optional<InventoryAlertType> inventoryAlertType;

    private final Optional<Long> inventoryAlertThreshold;

    private final Optional<String> userData;

    private final Optional<Long> serviceDuration;

    private final Optional<Boolean> availableForBooking;

    private final Optional<List<CatalogItemOptionValueForItemVariation>> itemOptionValues;

    private final Optional<String> measurementUnitId;

    private final Optional<Boolean> sellable;

    private final Optional<Boolean> stockable;

    private final Optional<List<String>> imageIds;

    private final Optional<List<String>> teamMemberIds;

    private final Optional<CatalogStockConversion> stockableConversion;

    private final Optional<String> kitchenName;

    private final Map<String, Object> additionalProperties;

    private CatalogItemVariation(
            Optional<String> itemId,
            Optional<String> name,
            Optional<String> sku,
            Optional<String> upc,
            Optional<Integer> ordinal,
            Optional<CatalogPricingType> pricingType,
            Optional<Money> priceMoney,
            Optional<List<ItemVariationLocationOverrides>> locationOverrides,
            Optional<Boolean> trackInventory,
            Optional<InventoryAlertType> inventoryAlertType,
            Optional<Long> inventoryAlertThreshold,
            Optional<String> userData,
            Optional<Long> serviceDuration,
            Optional<Boolean> availableForBooking,
            Optional<List<CatalogItemOptionValueForItemVariation>> itemOptionValues,
            Optional<String> measurementUnitId,
            Optional<Boolean> sellable,
            Optional<Boolean> stockable,
            Optional<List<String>> imageIds,
            Optional<List<String>> teamMemberIds,
            Optional<CatalogStockConversion> stockableConversion,
            Optional<String> kitchenName,
            Map<String, Object> additionalProperties) {
        this.itemId = itemId;
        this.name = name;
        this.sku = sku;
        this.upc = upc;
        this.ordinal = ordinal;
        this.pricingType = pricingType;
        this.priceMoney = priceMoney;
        this.locationOverrides = locationOverrides;
        this.trackInventory = trackInventory;
        this.inventoryAlertType = inventoryAlertType;
        this.inventoryAlertThreshold = inventoryAlertThreshold;
        this.userData = userData;
        this.serviceDuration = serviceDuration;
        this.availableForBooking = availableForBooking;
        this.itemOptionValues = itemOptionValues;
        this.measurementUnitId = measurementUnitId;
        this.sellable = sellable;
        this.stockable = stockable;
        this.imageIds = imageIds;
        this.teamMemberIds = teamMemberIds;
        this.stockableConversion = stockableConversion;
        this.kitchenName = kitchenName;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The ID of the <code>CatalogItem</code> associated with this item variation.
     */
    @JsonIgnore
    public Optional<String> getItemId() {
        if (itemId == null) {
            return Optional.empty();
        }
        return itemId;
    }

    /**
     * @return The item variation's name. This is a searchable attribute for use in applicable query filters.
     * <p>Its value has a maximum length of 255 Unicode code points. However, when the parent <a href="entity:CatalogItem">item</a>
     * uses <a href="entity:CatalogItemOption">item options</a>, this attribute is auto-generated, read-only, and can be
     * longer than 255 Unicode code points.</p>
     */
    @JsonIgnore
    public Optional<String> getName() {
        if (name == null) {
            return Optional.empty();
        }
        return name;
    }

    /**
     * @return The item variation's SKU, if any. This is a searchable attribute for use in applicable query filters.
     */
    @JsonIgnore
    public Optional<String> getSku() {
        if (sku == null) {
            return Optional.empty();
        }
        return sku;
    }

    /**
     * @return The universal product code (UPC) of the item variation, if any. This is a searchable attribute for use in applicable query filters.
     * <p>The value of this attribute should be a number of 12-14 digits long.  This restriction is enforced on the Square Seller Dashboard,
     * Square Point of Sale or Retail Point of Sale apps, where this attribute shows in the GTIN field. If a non-compliant UPC value is assigned
     * to this attribute using the API, the value is not editable on the Seller Dashboard, Square Point of Sale or Retail Point of Sale apps
     * unless it is updated to fit the expected format.</p>
     */
    @JsonIgnore
    public Optional<String> getUpc() {
        if (upc == null) {
            return Optional.empty();
        }
        return upc;
    }

    /**
     * @return The order in which this item variation should be displayed. This value is read-only. On writes, the ordinal
     * for each item variation within a parent <code>CatalogItem</code> is set according to the item variations's
     * position. On reads, the value is not guaranteed to be sequential or unique.
     */
    @JsonProperty("ordinal")
    public Optional<Integer> getOrdinal() {
        return ordinal;
    }

    /**
     * @return Indicates whether the item variation's price is fixed or determined at the time
     * of sale.
     * See <a href="#type-catalogpricingtype">CatalogPricingType</a> for possible values
     */
    @JsonProperty("pricing_type")
    public Optional<CatalogPricingType> getPricingType() {
        return pricingType;
    }

    /**
     * @return The item variation's price, if fixed pricing is used.
     */
    @JsonProperty("price_money")
    public Optional<Money> getPriceMoney() {
        return priceMoney;
    }

    /**
     * @return Per-location price and inventory overrides.
     */
    @JsonIgnore
    public Optional<List<ItemVariationLocationOverrides>> getLocationOverrides() {
        if (locationOverrides == null) {
            return Optional.empty();
        }
        return locationOverrides;
    }

    /**
     * @return If <code>true</code>, inventory tracking is active for the variation.
     */
    @JsonIgnore
    public Optional<Boolean> getTrackInventory() {
        if (trackInventory == null) {
            return Optional.empty();
        }
        return trackInventory;
    }

    /**
     * @return Indicates whether the item variation displays an alert when its inventory quantity is less than or equal
     * to its <code>inventory_alert_threshold</code>.
     * See <a href="#type-inventoryalerttype">InventoryAlertType</a> for possible values
     */
    @JsonProperty("inventory_alert_type")
    public Optional<InventoryAlertType> getInventoryAlertType() {
        return inventoryAlertType;
    }

    /**
     * @return If the inventory quantity for the variation is less than or equal to this value and <code>inventory_alert_type</code>
     * is <code>LOW_QUANTITY</code>, the variation displays an alert in the merchant dashboard.
     * <p>This value is always an integer.</p>
     */
    @JsonIgnore
    public Optional<Long> getInventoryAlertThreshold() {
        if (inventoryAlertThreshold == null) {
            return Optional.empty();
        }
        return inventoryAlertThreshold;
    }

    /**
     * @return Arbitrary user metadata to associate with the item variation. This attribute value length is of Unicode code points.
     */
    @JsonIgnore
    public Optional<String> getUserData() {
        if (userData == null) {
            return Optional.empty();
        }
        return userData;
    }

    /**
     * @return If the <code>CatalogItem</code> that owns this item variation is of type
     * <code>APPOINTMENTS_SERVICE</code>, then this is the duration of the service in milliseconds. For
     * example, a 30 minute appointment would have the value <code>1800000</code>, which is equal to
     * 30 (minutes) * 60 (seconds per minute) * 1000 (milliseconds per second).
     */
    @JsonIgnore
    public Optional<Long> getServiceDuration() {
        if (serviceDuration == null) {
            return Optional.empty();
        }
        return serviceDuration;
    }

    /**
     * @return If the <code>CatalogItem</code> that owns this item variation is of type
     * <code>APPOINTMENTS_SERVICE</code>, a bool representing whether this service is available for booking.
     */
    @JsonIgnore
    public Optional<Boolean> getAvailableForBooking() {
        if (availableForBooking == null) {
            return Optional.empty();
        }
        return availableForBooking;
    }

    /**
     * @return List of item option values associated with this item variation. Listed
     * in the same order as the item options of the parent item.
     */
    @JsonIgnore
    public Optional<List<CatalogItemOptionValueForItemVariation>> getItemOptionValues() {
        if (itemOptionValues == null) {
            return Optional.empty();
        }
        return itemOptionValues;
    }

    /**
     * @return ID of the ‘CatalogMeasurementUnit’ that is used to measure the quantity
     * sold of this item variation. If left unset, the item will be sold in
     * whole quantities.
     */
    @JsonIgnore
    public Optional<String> getMeasurementUnitId() {
        if (measurementUnitId == null) {
            return Optional.empty();
        }
        return measurementUnitId;
    }

    /**
     * @return Whether this variation can be sold. The inventory count of a sellable variation indicates
     * the number of units available for sale. When a variation is both stockable and sellable,
     * its sellable inventory count can be smaller than or equal to its stockable count.
     */
    @JsonIgnore
    public Optional<Boolean> getSellable() {
        if (sellable == null) {
            return Optional.empty();
        }
        return sellable;
    }

    /**
     * @return Whether stock is counted directly on this variation (TRUE) or only on its components (FALSE).
     * When a variation is both stockable and sellable, the inventory count of a stockable variation keeps track of the number of units of this variation in stock
     * and is not an indicator of the number of units of the variation that can be sold.
     */
    @JsonIgnore
    public Optional<Boolean> getStockable() {
        if (stockable == null) {
            return Optional.empty();
        }
        return stockable;
    }

    /**
     * @return The IDs of images associated with this <code>CatalogItemVariation</code> instance.
     * These images will be shown to customers in Square Online Store.
     */
    @JsonIgnore
    public Optional<List<String>> getImageIds() {
        if (imageIds == null) {
            return Optional.empty();
        }
        return imageIds;
    }

    /**
     * @return Tokens of employees that can perform the service represented by this variation. Only valid for
     * variations of type <code>APPOINTMENTS_SERVICE</code>.
     */
    @JsonIgnore
    public Optional<List<String>> getTeamMemberIds() {
        if (teamMemberIds == null) {
            return Optional.empty();
        }
        return teamMemberIds;
    }

    /**
     * @return The unit conversion rule, as prescribed by the <a href="entity:CatalogStockConversion">CatalogStockConversion</a> type,
     * that describes how this non-stockable (i.e., sellable/receivable) item variation is converted
     * to/from the stockable item variation sharing the same parent item. With the stock conversion,
     * you can accurately track inventory when an item variation is sold in one unit, but stocked in
     * another unit.
     */
    @JsonProperty("stockable_conversion")
    public Optional<CatalogStockConversion> getStockableConversion() {
        return stockableConversion;
    }

    /**
     * @return (Optional) Name that the restaurant wants to display to their kitchen workers
     * instead of the customer-facing name.
     * e.g., customer name might be &quot;Mega-Jumbo Triplesized&quot; and the
     * kitchen name is &quot;Large container&quot;
     */
    @JsonIgnore
    public Optional<String> getKitchenName() {
        if (kitchenName == null) {
            return Optional.empty();
        }
        return kitchenName;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("item_id")
    private Optional<String> _getItemId() {
        return itemId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("name")
    private Optional<String> _getName() {
        return name;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("sku")
    private Optional<String> _getSku() {
        return sku;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("upc")
    private Optional<String> _getUpc() {
        return upc;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("location_overrides")
    private Optional<List<ItemVariationLocationOverrides>> _getLocationOverrides() {
        return locationOverrides;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("track_inventory")
    private Optional<Boolean> _getTrackInventory() {
        return trackInventory;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("inventory_alert_threshold")
    private Optional<Long> _getInventoryAlertThreshold() {
        return inventoryAlertThreshold;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("user_data")
    private Optional<String> _getUserData() {
        return userData;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("service_duration")
    private Optional<Long> _getServiceDuration() {
        return serviceDuration;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("available_for_booking")
    private Optional<Boolean> _getAvailableForBooking() {
        return availableForBooking;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("item_option_values")
    private Optional<List<CatalogItemOptionValueForItemVariation>> _getItemOptionValues() {
        return itemOptionValues;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("measurement_unit_id")
    private Optional<String> _getMeasurementUnitId() {
        return measurementUnitId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("sellable")
    private Optional<Boolean> _getSellable() {
        return sellable;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("stockable")
    private Optional<Boolean> _getStockable() {
        return stockable;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("image_ids")
    private Optional<List<String>> _getImageIds() {
        return imageIds;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("team_member_ids")
    private Optional<List<String>> _getTeamMemberIds() {
        return teamMemberIds;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("kitchen_name")
    private Optional<String> _getKitchenName() {
        return kitchenName;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof CatalogItemVariation && equalTo((CatalogItemVariation) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(CatalogItemVariation other) {
        return itemId.equals(other.itemId)
                && name.equals(other.name)
                && sku.equals(other.sku)
                && upc.equals(other.upc)
                && ordinal.equals(other.ordinal)
                && pricingType.equals(other.pricingType)
                && priceMoney.equals(other.priceMoney)
                && locationOverrides.equals(other.locationOverrides)
                && trackInventory.equals(other.trackInventory)
                && inventoryAlertType.equals(other.inventoryAlertType)
                && inventoryAlertThreshold.equals(other.inventoryAlertThreshold)
                && userData.equals(other.userData)
                && serviceDuration.equals(other.serviceDuration)
                && availableForBooking.equals(other.availableForBooking)
                && itemOptionValues.equals(other.itemOptionValues)
                && measurementUnitId.equals(other.measurementUnitId)
                && sellable.equals(other.sellable)
                && stockable.equals(other.stockable)
                && imageIds.equals(other.imageIds)
                && teamMemberIds.equals(other.teamMemberIds)
                && stockableConversion.equals(other.stockableConversion)
                && kitchenName.equals(other.kitchenName);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.itemId,
                this.name,
                this.sku,
                this.upc,
                this.ordinal,
                this.pricingType,
                this.priceMoney,
                this.locationOverrides,
                this.trackInventory,
                this.inventoryAlertType,
                this.inventoryAlertThreshold,
                this.userData,
                this.serviceDuration,
                this.availableForBooking,
                this.itemOptionValues,
                this.measurementUnitId,
                this.sellable,
                this.stockable,
                this.imageIds,
                this.teamMemberIds,
                this.stockableConversion,
                this.kitchenName);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> itemId = Optional.empty();

        private Optional<String> name = Optional.empty();

        private Optional<String> sku = Optional.empty();

        private Optional<String> upc = Optional.empty();

        private Optional<Integer> ordinal = Optional.empty();

        private Optional<CatalogPricingType> pricingType = Optional.empty();

        private Optional<Money> priceMoney = Optional.empty();

        private Optional<List<ItemVariationLocationOverrides>> locationOverrides = Optional.empty();

        private Optional<Boolean> trackInventory = Optional.empty();

        private Optional<InventoryAlertType> inventoryAlertType = Optional.empty();

        private Optional<Long> inventoryAlertThreshold = Optional.empty();

        private Optional<String> userData = Optional.empty();

        private Optional<Long> serviceDuration = Optional.empty();

        private Optional<Boolean> availableForBooking = Optional.empty();

        private Optional<List<CatalogItemOptionValueForItemVariation>> itemOptionValues = Optional.empty();

        private Optional<String> measurementUnitId = Optional.empty();

        private Optional<Boolean> sellable = Optional.empty();

        private Optional<Boolean> stockable = Optional.empty();

        private Optional<List<String>> imageIds = Optional.empty();

        private Optional<List<String>> teamMemberIds = Optional.empty();

        private Optional<CatalogStockConversion> stockableConversion = Optional.empty();

        private Optional<String> kitchenName = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(CatalogItemVariation other) {
            itemId(other.getItemId());
            name(other.getName());
            sku(other.getSku());
            upc(other.getUpc());
            ordinal(other.getOrdinal());
            pricingType(other.getPricingType());
            priceMoney(other.getPriceMoney());
            locationOverrides(other.getLocationOverrides());
            trackInventory(other.getTrackInventory());
            inventoryAlertType(other.getInventoryAlertType());
            inventoryAlertThreshold(other.getInventoryAlertThreshold());
            userData(other.getUserData());
            serviceDuration(other.getServiceDuration());
            availableForBooking(other.getAvailableForBooking());
            itemOptionValues(other.getItemOptionValues());
            measurementUnitId(other.getMeasurementUnitId());
            sellable(other.getSellable());
            stockable(other.getStockable());
            imageIds(other.getImageIds());
            teamMemberIds(other.getTeamMemberIds());
            stockableConversion(other.getStockableConversion());
            kitchenName(other.getKitchenName());
            return this;
        }

        /**
         * <p>The ID of the <code>CatalogItem</code> associated with this item variation.</p>
         */
        @JsonSetter(value = "item_id", nulls = Nulls.SKIP)
        public Builder itemId(Optional<String> itemId) {
            this.itemId = itemId;
            return this;
        }

        public Builder itemId(String itemId) {
            this.itemId = Optional.ofNullable(itemId);
            return this;
        }

        public Builder itemId(Nullable<String> itemId) {
            if (itemId.isNull()) {
                this.itemId = null;
            } else if (itemId.isEmpty()) {
                this.itemId = Optional.empty();
            } else {
                this.itemId = Optional.of(itemId.get());
            }
            return this;
        }

        /**
         * <p>The item variation's name. This is a searchable attribute for use in applicable query filters.</p>
         * <p>Its value has a maximum length of 255 Unicode code points. However, when the parent <a href="entity:CatalogItem">item</a>
         * uses <a href="entity:CatalogItemOption">item options</a>, this attribute is auto-generated, read-only, and can be
         * longer than 255 Unicode code points.</p>
         */
        @JsonSetter(value = "name", nulls = Nulls.SKIP)
        public Builder name(Optional<String> name) {
            this.name = name;
            return this;
        }

        public Builder name(String name) {
            this.name = Optional.ofNullable(name);
            return this;
        }

        public Builder name(Nullable<String> name) {
            if (name.isNull()) {
                this.name = null;
            } else if (name.isEmpty()) {
                this.name = Optional.empty();
            } else {
                this.name = Optional.of(name.get());
            }
            return this;
        }

        /**
         * <p>The item variation's SKU, if any. This is a searchable attribute for use in applicable query filters.</p>
         */
        @JsonSetter(value = "sku", nulls = Nulls.SKIP)
        public Builder sku(Optional<String> sku) {
            this.sku = sku;
            return this;
        }

        public Builder sku(String sku) {
            this.sku = Optional.ofNullable(sku);
            return this;
        }

        public Builder sku(Nullable<String> sku) {
            if (sku.isNull()) {
                this.sku = null;
            } else if (sku.isEmpty()) {
                this.sku = Optional.empty();
            } else {
                this.sku = Optional.of(sku.get());
            }
            return this;
        }

        /**
         * <p>The universal product code (UPC) of the item variation, if any. This is a searchable attribute for use in applicable query filters.</p>
         * <p>The value of this attribute should be a number of 12-14 digits long.  This restriction is enforced on the Square Seller Dashboard,
         * Square Point of Sale or Retail Point of Sale apps, where this attribute shows in the GTIN field. If a non-compliant UPC value is assigned
         * to this attribute using the API, the value is not editable on the Seller Dashboard, Square Point of Sale or Retail Point of Sale apps
         * unless it is updated to fit the expected format.</p>
         */
        @JsonSetter(value = "upc", nulls = Nulls.SKIP)
        public Builder upc(Optional<String> upc) {
            this.upc = upc;
            return this;
        }

        public Builder upc(String upc) {
            this.upc = Optional.ofNullable(upc);
            return this;
        }

        public Builder upc(Nullable<String> upc) {
            if (upc.isNull()) {
                this.upc = null;
            } else if (upc.isEmpty()) {
                this.upc = Optional.empty();
            } else {
                this.upc = Optional.of(upc.get());
            }
            return this;
        }

        /**
         * <p>The order in which this item variation should be displayed. This value is read-only. On writes, the ordinal
         * for each item variation within a parent <code>CatalogItem</code> is set according to the item variations's
         * position. On reads, the value is not guaranteed to be sequential or unique.</p>
         */
        @JsonSetter(value = "ordinal", nulls = Nulls.SKIP)
        public Builder ordinal(Optional<Integer> ordinal) {
            this.ordinal = ordinal;
            return this;
        }

        public Builder ordinal(Integer ordinal) {
            this.ordinal = Optional.ofNullable(ordinal);
            return this;
        }

        /**
         * <p>Indicates whether the item variation's price is fixed or determined at the time
         * of sale.
         * See <a href="#type-catalogpricingtype">CatalogPricingType</a> for possible values</p>
         */
        @JsonSetter(value = "pricing_type", nulls = Nulls.SKIP)
        public Builder pricingType(Optional<CatalogPricingType> pricingType) {
            this.pricingType = pricingType;
            return this;
        }

        public Builder pricingType(CatalogPricingType pricingType) {
            this.pricingType = Optional.ofNullable(pricingType);
            return this;
        }

        /**
         * <p>The item variation's price, if fixed pricing is used.</p>
         */
        @JsonSetter(value = "price_money", nulls = Nulls.SKIP)
        public Builder priceMoney(Optional<Money> priceMoney) {
            this.priceMoney = priceMoney;
            return this;
        }

        public Builder priceMoney(Money priceMoney) {
            this.priceMoney = Optional.ofNullable(priceMoney);
            return this;
        }

        /**
         * <p>Per-location price and inventory overrides.</p>
         */
        @JsonSetter(value = "location_overrides", nulls = Nulls.SKIP)
        public Builder locationOverrides(Optional<List<ItemVariationLocationOverrides>> locationOverrides) {
            this.locationOverrides = locationOverrides;
            return this;
        }

        public Builder locationOverrides(List<ItemVariationLocationOverrides> locationOverrides) {
            this.locationOverrides = Optional.ofNullable(locationOverrides);
            return this;
        }

        public Builder locationOverrides(Nullable<List<ItemVariationLocationOverrides>> locationOverrides) {
            if (locationOverrides.isNull()) {
                this.locationOverrides = null;
            } else if (locationOverrides.isEmpty()) {
                this.locationOverrides = Optional.empty();
            } else {
                this.locationOverrides = Optional.of(locationOverrides.get());
            }
            return this;
        }

        /**
         * <p>If <code>true</code>, inventory tracking is active for the variation.</p>
         */
        @JsonSetter(value = "track_inventory", nulls = Nulls.SKIP)
        public Builder trackInventory(Optional<Boolean> trackInventory) {
            this.trackInventory = trackInventory;
            return this;
        }

        public Builder trackInventory(Boolean trackInventory) {
            this.trackInventory = Optional.ofNullable(trackInventory);
            return this;
        }

        public Builder trackInventory(Nullable<Boolean> trackInventory) {
            if (trackInventory.isNull()) {
                this.trackInventory = null;
            } else if (trackInventory.isEmpty()) {
                this.trackInventory = Optional.empty();
            } else {
                this.trackInventory = Optional.of(trackInventory.get());
            }
            return this;
        }

        /**
         * <p>Indicates whether the item variation displays an alert when its inventory quantity is less than or equal
         * to its <code>inventory_alert_threshold</code>.
         * See <a href="#type-inventoryalerttype">InventoryAlertType</a> for possible values</p>
         */
        @JsonSetter(value = "inventory_alert_type", nulls = Nulls.SKIP)
        public Builder inventoryAlertType(Optional<InventoryAlertType> inventoryAlertType) {
            this.inventoryAlertType = inventoryAlertType;
            return this;
        }

        public Builder inventoryAlertType(InventoryAlertType inventoryAlertType) {
            this.inventoryAlertType = Optional.ofNullable(inventoryAlertType);
            return this;
        }

        /**
         * <p>If the inventory quantity for the variation is less than or equal to this value and <code>inventory_alert_type</code>
         * is <code>LOW_QUANTITY</code>, the variation displays an alert in the merchant dashboard.</p>
         * <p>This value is always an integer.</p>
         */
        @JsonSetter(value = "inventory_alert_threshold", nulls = Nulls.SKIP)
        public Builder inventoryAlertThreshold(Optional<Long> inventoryAlertThreshold) {
            this.inventoryAlertThreshold = inventoryAlertThreshold;
            return this;
        }

        public Builder inventoryAlertThreshold(Long inventoryAlertThreshold) {
            this.inventoryAlertThreshold = Optional.ofNullable(inventoryAlertThreshold);
            return this;
        }

        public Builder inventoryAlertThreshold(Nullable<Long> inventoryAlertThreshold) {
            if (inventoryAlertThreshold.isNull()) {
                this.inventoryAlertThreshold = null;
            } else if (inventoryAlertThreshold.isEmpty()) {
                this.inventoryAlertThreshold = Optional.empty();
            } else {
                this.inventoryAlertThreshold = Optional.of(inventoryAlertThreshold.get());
            }
            return this;
        }

        /**
         * <p>Arbitrary user metadata to associate with the item variation. This attribute value length is of Unicode code points.</p>
         */
        @JsonSetter(value = "user_data", nulls = Nulls.SKIP)
        public Builder userData(Optional<String> userData) {
            this.userData = userData;
            return this;
        }

        public Builder userData(String userData) {
            this.userData = Optional.ofNullable(userData);
            return this;
        }

        public Builder userData(Nullable<String> userData) {
            if (userData.isNull()) {
                this.userData = null;
            } else if (userData.isEmpty()) {
                this.userData = Optional.empty();
            } else {
                this.userData = Optional.of(userData.get());
            }
            return this;
        }

        /**
         * <p>If the <code>CatalogItem</code> that owns this item variation is of type
         * <code>APPOINTMENTS_SERVICE</code>, then this is the duration of the service in milliseconds. For
         * example, a 30 minute appointment would have the value <code>1800000</code>, which is equal to
         * 30 (minutes) * 60 (seconds per minute) * 1000 (milliseconds per second).</p>
         */
        @JsonSetter(value = "service_duration", nulls = Nulls.SKIP)
        public Builder serviceDuration(Optional<Long> serviceDuration) {
            this.serviceDuration = serviceDuration;
            return this;
        }

        public Builder serviceDuration(Long serviceDuration) {
            this.serviceDuration = Optional.ofNullable(serviceDuration);
            return this;
        }

        public Builder serviceDuration(Nullable<Long> serviceDuration) {
            if (serviceDuration.isNull()) {
                this.serviceDuration = null;
            } else if (serviceDuration.isEmpty()) {
                this.serviceDuration = Optional.empty();
            } else {
                this.serviceDuration = Optional.of(serviceDuration.get());
            }
            return this;
        }

        /**
         * <p>If the <code>CatalogItem</code> that owns this item variation is of type
         * <code>APPOINTMENTS_SERVICE</code>, a bool representing whether this service is available for booking.</p>
         */
        @JsonSetter(value = "available_for_booking", nulls = Nulls.SKIP)
        public Builder availableForBooking(Optional<Boolean> availableForBooking) {
            this.availableForBooking = availableForBooking;
            return this;
        }

        public Builder availableForBooking(Boolean availableForBooking) {
            this.availableForBooking = Optional.ofNullable(availableForBooking);
            return this;
        }

        public Builder availableForBooking(Nullable<Boolean> availableForBooking) {
            if (availableForBooking.isNull()) {
                this.availableForBooking = null;
            } else if (availableForBooking.isEmpty()) {
                this.availableForBooking = Optional.empty();
            } else {
                this.availableForBooking = Optional.of(availableForBooking.get());
            }
            return this;
        }

        /**
         * <p>List of item option values associated with this item variation. Listed
         * in the same order as the item options of the parent item.</p>
         */
        @JsonSetter(value = "item_option_values", nulls = Nulls.SKIP)
        public Builder itemOptionValues(Optional<List<CatalogItemOptionValueForItemVariation>> itemOptionValues) {
            this.itemOptionValues = itemOptionValues;
            return this;
        }

        public Builder itemOptionValues(List<CatalogItemOptionValueForItemVariation> itemOptionValues) {
            this.itemOptionValues = Optional.ofNullable(itemOptionValues);
            return this;
        }

        public Builder itemOptionValues(Nullable<List<CatalogItemOptionValueForItemVariation>> itemOptionValues) {
            if (itemOptionValues.isNull()) {
                this.itemOptionValues = null;
            } else if (itemOptionValues.isEmpty()) {
                this.itemOptionValues = Optional.empty();
            } else {
                this.itemOptionValues = Optional.of(itemOptionValues.get());
            }
            return this;
        }

        /**
         * <p>ID of the ‘CatalogMeasurementUnit’ that is used to measure the quantity
         * sold of this item variation. If left unset, the item will be sold in
         * whole quantities.</p>
         */
        @JsonSetter(value = "measurement_unit_id", nulls = Nulls.SKIP)
        public Builder measurementUnitId(Optional<String> measurementUnitId) {
            this.measurementUnitId = measurementUnitId;
            return this;
        }

        public Builder measurementUnitId(String measurementUnitId) {
            this.measurementUnitId = Optional.ofNullable(measurementUnitId);
            return this;
        }

        public Builder measurementUnitId(Nullable<String> measurementUnitId) {
            if (measurementUnitId.isNull()) {
                this.measurementUnitId = null;
            } else if (measurementUnitId.isEmpty()) {
                this.measurementUnitId = Optional.empty();
            } else {
                this.measurementUnitId = Optional.of(measurementUnitId.get());
            }
            return this;
        }

        /**
         * <p>Whether this variation can be sold. The inventory count of a sellable variation indicates
         * the number of units available for sale. When a variation is both stockable and sellable,
         * its sellable inventory count can be smaller than or equal to its stockable count.</p>
         */
        @JsonSetter(value = "sellable", nulls = Nulls.SKIP)
        public Builder sellable(Optional<Boolean> sellable) {
            this.sellable = sellable;
            return this;
        }

        public Builder sellable(Boolean sellable) {
            this.sellable = Optional.ofNullable(sellable);
            return this;
        }

        public Builder sellable(Nullable<Boolean> sellable) {
            if (sellable.isNull()) {
                this.sellable = null;
            } else if (sellable.isEmpty()) {
                this.sellable = Optional.empty();
            } else {
                this.sellable = Optional.of(sellable.get());
            }
            return this;
        }

        /**
         * <p>Whether stock is counted directly on this variation (TRUE) or only on its components (FALSE).
         * When a variation is both stockable and sellable, the inventory count of a stockable variation keeps track of the number of units of this variation in stock
         * and is not an indicator of the number of units of the variation that can be sold.</p>
         */
        @JsonSetter(value = "stockable", nulls = Nulls.SKIP)
        public Builder stockable(Optional<Boolean> stockable) {
            this.stockable = stockable;
            return this;
        }

        public Builder stockable(Boolean stockable) {
            this.stockable = Optional.ofNullable(stockable);
            return this;
        }

        public Builder stockable(Nullable<Boolean> stockable) {
            if (stockable.isNull()) {
                this.stockable = null;
            } else if (stockable.isEmpty()) {
                this.stockable = Optional.empty();
            } else {
                this.stockable = Optional.of(stockable.get());
            }
            return this;
        }

        /**
         * <p>The IDs of images associated with this <code>CatalogItemVariation</code> instance.
         * These images will be shown to customers in Square Online Store.</p>
         */
        @JsonSetter(value = "image_ids", nulls = Nulls.SKIP)
        public Builder imageIds(Optional<List<String>> imageIds) {
            this.imageIds = imageIds;
            return this;
        }

        public Builder imageIds(List<String> imageIds) {
            this.imageIds = Optional.ofNullable(imageIds);
            return this;
        }

        public Builder imageIds(Nullable<List<String>> imageIds) {
            if (imageIds.isNull()) {
                this.imageIds = null;
            } else if (imageIds.isEmpty()) {
                this.imageIds = Optional.empty();
            } else {
                this.imageIds = Optional.of(imageIds.get());
            }
            return this;
        }

        /**
         * <p>Tokens of employees that can perform the service represented by this variation. Only valid for
         * variations of type <code>APPOINTMENTS_SERVICE</code>.</p>
         */
        @JsonSetter(value = "team_member_ids", nulls = Nulls.SKIP)
        public Builder teamMemberIds(Optional<List<String>> teamMemberIds) {
            this.teamMemberIds = teamMemberIds;
            return this;
        }

        public Builder teamMemberIds(List<String> teamMemberIds) {
            this.teamMemberIds = Optional.ofNullable(teamMemberIds);
            return this;
        }

        public Builder teamMemberIds(Nullable<List<String>> teamMemberIds) {
            if (teamMemberIds.isNull()) {
                this.teamMemberIds = null;
            } else if (teamMemberIds.isEmpty()) {
                this.teamMemberIds = Optional.empty();
            } else {
                this.teamMemberIds = Optional.of(teamMemberIds.get());
            }
            return this;
        }

        /**
         * <p>The unit conversion rule, as prescribed by the <a href="entity:CatalogStockConversion">CatalogStockConversion</a> type,
         * that describes how this non-stockable (i.e., sellable/receivable) item variation is converted
         * to/from the stockable item variation sharing the same parent item. With the stock conversion,
         * you can accurately track inventory when an item variation is sold in one unit, but stocked in
         * another unit.</p>
         */
        @JsonSetter(value = "stockable_conversion", nulls = Nulls.SKIP)
        public Builder stockableConversion(Optional<CatalogStockConversion> stockableConversion) {
            this.stockableConversion = stockableConversion;
            return this;
        }

        public Builder stockableConversion(CatalogStockConversion stockableConversion) {
            this.stockableConversion = Optional.ofNullable(stockableConversion);
            return this;
        }

        /**
         * <p>(Optional) Name that the restaurant wants to display to their kitchen workers
         * instead of the customer-facing name.
         * e.g., customer name might be &quot;Mega-Jumbo Triplesized&quot; and the
         * kitchen name is &quot;Large container&quot;</p>
         */
        @JsonSetter(value = "kitchen_name", nulls = Nulls.SKIP)
        public Builder kitchenName(Optional<String> kitchenName) {
            this.kitchenName = kitchenName;
            return this;
        }

        public Builder kitchenName(String kitchenName) {
            this.kitchenName = Optional.ofNullable(kitchenName);
            return this;
        }

        public Builder kitchenName(Nullable<String> kitchenName) {
            if (kitchenName.isNull()) {
                this.kitchenName = null;
            } else if (kitchenName.isEmpty()) {
                this.kitchenName = Optional.empty();
            } else {
                this.kitchenName = Optional.of(kitchenName.get());
            }
            return this;
        }

        public CatalogItemVariation build() {
            return new CatalogItemVariation(
                    itemId,
                    name,
                    sku,
                    upc,
                    ordinal,
                    pricingType,
                    priceMoney,
                    locationOverrides,
                    trackInventory,
                    inventoryAlertType,
                    inventoryAlertThreshold,
                    userData,
                    serviceDuration,
                    availableForBooking,
                    itemOptionValues,
                    measurementUnitId,
                    sellable,
                    stockable,
                    imageIds,
                    teamMemberIds,
                    stockableConversion,
                    kitchenName,
                    additionalProperties);
        }
    }
}
