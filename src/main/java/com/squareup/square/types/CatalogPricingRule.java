/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.squareup.square.core.Nullable;
import com.squareup.square.core.NullableNonemptyFilter;
import com.squareup.square.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = CatalogPricingRule.Builder.class)
public final class CatalogPricingRule {
    private final Optional<String> name;

    private final Optional<List<String>> timePeriodIds;

    private final Optional<String> discountId;

    private final Optional<String> matchProductsId;

    private final Optional<String> applyProductsId;

    private final Optional<String> excludeProductsId;

    private final Optional<String> validFromDate;

    private final Optional<String> validFromLocalTime;

    private final Optional<String> validUntilDate;

    private final Optional<String> validUntilLocalTime;

    private final Optional<ExcludeStrategy> excludeStrategy;

    private final Optional<Money> minimumOrderSubtotalMoney;

    private final Optional<List<String>> customerGroupIdsAny;

    private final Map<String, Object> additionalProperties;

    private CatalogPricingRule(
            Optional<String> name,
            Optional<List<String>> timePeriodIds,
            Optional<String> discountId,
            Optional<String> matchProductsId,
            Optional<String> applyProductsId,
            Optional<String> excludeProductsId,
            Optional<String> validFromDate,
            Optional<String> validFromLocalTime,
            Optional<String> validUntilDate,
            Optional<String> validUntilLocalTime,
            Optional<ExcludeStrategy> excludeStrategy,
            Optional<Money> minimumOrderSubtotalMoney,
            Optional<List<String>> customerGroupIdsAny,
            Map<String, Object> additionalProperties) {
        this.name = name;
        this.timePeriodIds = timePeriodIds;
        this.discountId = discountId;
        this.matchProductsId = matchProductsId;
        this.applyProductsId = applyProductsId;
        this.excludeProductsId = excludeProductsId;
        this.validFromDate = validFromDate;
        this.validFromLocalTime = validFromLocalTime;
        this.validUntilDate = validUntilDate;
        this.validUntilLocalTime = validUntilLocalTime;
        this.excludeStrategy = excludeStrategy;
        this.minimumOrderSubtotalMoney = minimumOrderSubtotalMoney;
        this.customerGroupIdsAny = customerGroupIdsAny;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return User-defined name for the pricing rule. For example, &quot;Buy one get one
     * free&quot; or &quot;10% off&quot;.
     */
    @JsonIgnore
    public Optional<String> getName() {
        if (name == null) {
            return Optional.empty();
        }
        return name;
    }

    /**
     * @return A list of unique IDs for the catalog time periods when
     * this pricing rule is in effect. If left unset, the pricing rule is always
     * in effect.
     */
    @JsonIgnore
    public Optional<List<String>> getTimePeriodIds() {
        if (timePeriodIds == null) {
            return Optional.empty();
        }
        return timePeriodIds;
    }

    /**
     * @return Unique ID for the <code>CatalogDiscount</code> to take off
     * the price of all matched items.
     */
    @JsonIgnore
    public Optional<String> getDiscountId() {
        if (discountId == null) {
            return Optional.empty();
        }
        return discountId;
    }

    /**
     * @return Unique ID for the <code>CatalogProductSet</code> that will be matched by this rule. A match rule
     * matches within the entire cart, and can match multiple times. This field will always be set.
     */
    @JsonIgnore
    public Optional<String> getMatchProductsId() {
        if (matchProductsId == null) {
            return Optional.empty();
        }
        return matchProductsId;
    }

    /**
     * @return <strong>Deprecated</strong>: Please use the <code>exclude_products_id</code> field to apply
     * an exclude set instead. Exclude sets allow better control over quantity
     * ranges and offer more flexibility for which matched items receive a discount.
     * <p><code>CatalogProductSet</code> to apply the pricing to.
     * An apply rule matches within the subset of the cart that fits the match rules (the match set).
     * An apply rule can only match once in the match set.
     * If not supplied, the pricing will be applied to all products in the match set.
     * Other products retain their base price, or a price generated by other rules.</p>
     */
    @JsonIgnore
    public Optional<String> getApplyProductsId() {
        if (applyProductsId == null) {
            return Optional.empty();
        }
        return applyProductsId;
    }

    /**
     * @return <code>CatalogProductSet</code> to exclude from the pricing rule.
     * An exclude rule matches within the subset of the cart that fits the match rules (the match set).
     * An exclude rule can only match once in the match set.
     * If not supplied, the pricing will be applied to all products in the match set.
     * Other products retain their base price, or a price generated by other rules.
     */
    @JsonIgnore
    public Optional<String> getExcludeProductsId() {
        if (excludeProductsId == null) {
            return Optional.empty();
        }
        return excludeProductsId;
    }

    /**
     * @return Represents the date the Pricing Rule is valid from. Represented in RFC 3339 full-date format (YYYY-MM-DD).
     */
    @JsonIgnore
    public Optional<String> getValidFromDate() {
        if (validFromDate == null) {
            return Optional.empty();
        }
        return validFromDate;
    }

    /**
     * @return Represents the local time the pricing rule should be valid from. Represented in RFC 3339 partial-time format
     * (HH:MM:SS). Partial seconds will be truncated.
     */
    @JsonIgnore
    public Optional<String> getValidFromLocalTime() {
        if (validFromLocalTime == null) {
            return Optional.empty();
        }
        return validFromLocalTime;
    }

    /**
     * @return Represents the date the Pricing Rule is valid until. Represented in RFC 3339 full-date format (YYYY-MM-DD).
     */
    @JsonIgnore
    public Optional<String> getValidUntilDate() {
        if (validUntilDate == null) {
            return Optional.empty();
        }
        return validUntilDate;
    }

    /**
     * @return Represents the local time the pricing rule should be valid until. Represented in RFC 3339 partial-time format
     * (HH:MM:SS). Partial seconds will be truncated.
     */
    @JsonIgnore
    public Optional<String> getValidUntilLocalTime() {
        if (validUntilLocalTime == null) {
            return Optional.empty();
        }
        return validUntilLocalTime;
    }

    /**
     * @return If an <code>exclude_products_id</code> was given, controls which subset of matched
     * products is excluded from any discounts.
     * <p>Default value: <code>LEAST_EXPENSIVE</code>
     * See <a href="#type-excludestrategy">ExcludeStrategy</a> for possible values</p>
     */
    @JsonProperty("exclude_strategy")
    public Optional<ExcludeStrategy> getExcludeStrategy() {
        return excludeStrategy;
    }

    /**
     * @return The minimum order subtotal (before discounts or taxes are applied)
     * that must be met before this rule may be applied.
     */
    @JsonProperty("minimum_order_subtotal_money")
    public Optional<Money> getMinimumOrderSubtotalMoney() {
        return minimumOrderSubtotalMoney;
    }

    /**
     * @return A list of IDs of customer groups, the members of which are eligible for discounts specified in this pricing rule.
     * Notice that a group ID is generated by the Customers API.
     * If this field is not set, the specified discount applies to matched products sold to anyone whether the buyer
     * has a customer profile created or not. If this <code>customer_group_ids_any</code> field is set, the specified discount
     * applies only to matched products sold to customers belonging to the specified customer groups.
     */
    @JsonIgnore
    public Optional<List<String>> getCustomerGroupIdsAny() {
        if (customerGroupIdsAny == null) {
            return Optional.empty();
        }
        return customerGroupIdsAny;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("name")
    private Optional<String> _getName() {
        return name;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("time_period_ids")
    private Optional<List<String>> _getTimePeriodIds() {
        return timePeriodIds;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("discount_id")
    private Optional<String> _getDiscountId() {
        return discountId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("match_products_id")
    private Optional<String> _getMatchProductsId() {
        return matchProductsId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("apply_products_id")
    private Optional<String> _getApplyProductsId() {
        return applyProductsId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("exclude_products_id")
    private Optional<String> _getExcludeProductsId() {
        return excludeProductsId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("valid_from_date")
    private Optional<String> _getValidFromDate() {
        return validFromDate;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("valid_from_local_time")
    private Optional<String> _getValidFromLocalTime() {
        return validFromLocalTime;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("valid_until_date")
    private Optional<String> _getValidUntilDate() {
        return validUntilDate;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("valid_until_local_time")
    private Optional<String> _getValidUntilLocalTime() {
        return validUntilLocalTime;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("customer_group_ids_any")
    private Optional<List<String>> _getCustomerGroupIdsAny() {
        return customerGroupIdsAny;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof CatalogPricingRule && equalTo((CatalogPricingRule) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(CatalogPricingRule other) {
        return name.equals(other.name)
                && timePeriodIds.equals(other.timePeriodIds)
                && discountId.equals(other.discountId)
                && matchProductsId.equals(other.matchProductsId)
                && applyProductsId.equals(other.applyProductsId)
                && excludeProductsId.equals(other.excludeProductsId)
                && validFromDate.equals(other.validFromDate)
                && validFromLocalTime.equals(other.validFromLocalTime)
                && validUntilDate.equals(other.validUntilDate)
                && validUntilLocalTime.equals(other.validUntilLocalTime)
                && excludeStrategy.equals(other.excludeStrategy)
                && minimumOrderSubtotalMoney.equals(other.minimumOrderSubtotalMoney)
                && customerGroupIdsAny.equals(other.customerGroupIdsAny);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.name,
                this.timePeriodIds,
                this.discountId,
                this.matchProductsId,
                this.applyProductsId,
                this.excludeProductsId,
                this.validFromDate,
                this.validFromLocalTime,
                this.validUntilDate,
                this.validUntilLocalTime,
                this.excludeStrategy,
                this.minimumOrderSubtotalMoney,
                this.customerGroupIdsAny);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> name = Optional.empty();

        private Optional<List<String>> timePeriodIds = Optional.empty();

        private Optional<String> discountId = Optional.empty();

        private Optional<String> matchProductsId = Optional.empty();

        private Optional<String> applyProductsId = Optional.empty();

        private Optional<String> excludeProductsId = Optional.empty();

        private Optional<String> validFromDate = Optional.empty();

        private Optional<String> validFromLocalTime = Optional.empty();

        private Optional<String> validUntilDate = Optional.empty();

        private Optional<String> validUntilLocalTime = Optional.empty();

        private Optional<ExcludeStrategy> excludeStrategy = Optional.empty();

        private Optional<Money> minimumOrderSubtotalMoney = Optional.empty();

        private Optional<List<String>> customerGroupIdsAny = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(CatalogPricingRule other) {
            name(other.getName());
            timePeriodIds(other.getTimePeriodIds());
            discountId(other.getDiscountId());
            matchProductsId(other.getMatchProductsId());
            applyProductsId(other.getApplyProductsId());
            excludeProductsId(other.getExcludeProductsId());
            validFromDate(other.getValidFromDate());
            validFromLocalTime(other.getValidFromLocalTime());
            validUntilDate(other.getValidUntilDate());
            validUntilLocalTime(other.getValidUntilLocalTime());
            excludeStrategy(other.getExcludeStrategy());
            minimumOrderSubtotalMoney(other.getMinimumOrderSubtotalMoney());
            customerGroupIdsAny(other.getCustomerGroupIdsAny());
            return this;
        }

        @JsonSetter(value = "name", nulls = Nulls.SKIP)
        public Builder name(Optional<String> name) {
            this.name = name;
            return this;
        }

        public Builder name(String name) {
            this.name = Optional.ofNullable(name);
            return this;
        }

        public Builder name(Nullable<String> name) {
            if (name.isNull()) {
                this.name = null;
            } else if (name.isEmpty()) {
                this.name = Optional.empty();
            } else {
                this.name = Optional.of(name.get());
            }
            return this;
        }

        @JsonSetter(value = "time_period_ids", nulls = Nulls.SKIP)
        public Builder timePeriodIds(Optional<List<String>> timePeriodIds) {
            this.timePeriodIds = timePeriodIds;
            return this;
        }

        public Builder timePeriodIds(List<String> timePeriodIds) {
            this.timePeriodIds = Optional.ofNullable(timePeriodIds);
            return this;
        }

        public Builder timePeriodIds(Nullable<List<String>> timePeriodIds) {
            if (timePeriodIds.isNull()) {
                this.timePeriodIds = null;
            } else if (timePeriodIds.isEmpty()) {
                this.timePeriodIds = Optional.empty();
            } else {
                this.timePeriodIds = Optional.of(timePeriodIds.get());
            }
            return this;
        }

        @JsonSetter(value = "discount_id", nulls = Nulls.SKIP)
        public Builder discountId(Optional<String> discountId) {
            this.discountId = discountId;
            return this;
        }

        public Builder discountId(String discountId) {
            this.discountId = Optional.ofNullable(discountId);
            return this;
        }

        public Builder discountId(Nullable<String> discountId) {
            if (discountId.isNull()) {
                this.discountId = null;
            } else if (discountId.isEmpty()) {
                this.discountId = Optional.empty();
            } else {
                this.discountId = Optional.of(discountId.get());
            }
            return this;
        }

        @JsonSetter(value = "match_products_id", nulls = Nulls.SKIP)
        public Builder matchProductsId(Optional<String> matchProductsId) {
            this.matchProductsId = matchProductsId;
            return this;
        }

        public Builder matchProductsId(String matchProductsId) {
            this.matchProductsId = Optional.ofNullable(matchProductsId);
            return this;
        }

        public Builder matchProductsId(Nullable<String> matchProductsId) {
            if (matchProductsId.isNull()) {
                this.matchProductsId = null;
            } else if (matchProductsId.isEmpty()) {
                this.matchProductsId = Optional.empty();
            } else {
                this.matchProductsId = Optional.of(matchProductsId.get());
            }
            return this;
        }

        @JsonSetter(value = "apply_products_id", nulls = Nulls.SKIP)
        public Builder applyProductsId(Optional<String> applyProductsId) {
            this.applyProductsId = applyProductsId;
            return this;
        }

        public Builder applyProductsId(String applyProductsId) {
            this.applyProductsId = Optional.ofNullable(applyProductsId);
            return this;
        }

        public Builder applyProductsId(Nullable<String> applyProductsId) {
            if (applyProductsId.isNull()) {
                this.applyProductsId = null;
            } else if (applyProductsId.isEmpty()) {
                this.applyProductsId = Optional.empty();
            } else {
                this.applyProductsId = Optional.of(applyProductsId.get());
            }
            return this;
        }

        @JsonSetter(value = "exclude_products_id", nulls = Nulls.SKIP)
        public Builder excludeProductsId(Optional<String> excludeProductsId) {
            this.excludeProductsId = excludeProductsId;
            return this;
        }

        public Builder excludeProductsId(String excludeProductsId) {
            this.excludeProductsId = Optional.ofNullable(excludeProductsId);
            return this;
        }

        public Builder excludeProductsId(Nullable<String> excludeProductsId) {
            if (excludeProductsId.isNull()) {
                this.excludeProductsId = null;
            } else if (excludeProductsId.isEmpty()) {
                this.excludeProductsId = Optional.empty();
            } else {
                this.excludeProductsId = Optional.of(excludeProductsId.get());
            }
            return this;
        }

        @JsonSetter(value = "valid_from_date", nulls = Nulls.SKIP)
        public Builder validFromDate(Optional<String> validFromDate) {
            this.validFromDate = validFromDate;
            return this;
        }

        public Builder validFromDate(String validFromDate) {
            this.validFromDate = Optional.ofNullable(validFromDate);
            return this;
        }

        public Builder validFromDate(Nullable<String> validFromDate) {
            if (validFromDate.isNull()) {
                this.validFromDate = null;
            } else if (validFromDate.isEmpty()) {
                this.validFromDate = Optional.empty();
            } else {
                this.validFromDate = Optional.of(validFromDate.get());
            }
            return this;
        }

        @JsonSetter(value = "valid_from_local_time", nulls = Nulls.SKIP)
        public Builder validFromLocalTime(Optional<String> validFromLocalTime) {
            this.validFromLocalTime = validFromLocalTime;
            return this;
        }

        public Builder validFromLocalTime(String validFromLocalTime) {
            this.validFromLocalTime = Optional.ofNullable(validFromLocalTime);
            return this;
        }

        public Builder validFromLocalTime(Nullable<String> validFromLocalTime) {
            if (validFromLocalTime.isNull()) {
                this.validFromLocalTime = null;
            } else if (validFromLocalTime.isEmpty()) {
                this.validFromLocalTime = Optional.empty();
            } else {
                this.validFromLocalTime = Optional.of(validFromLocalTime.get());
            }
            return this;
        }

        @JsonSetter(value = "valid_until_date", nulls = Nulls.SKIP)
        public Builder validUntilDate(Optional<String> validUntilDate) {
            this.validUntilDate = validUntilDate;
            return this;
        }

        public Builder validUntilDate(String validUntilDate) {
            this.validUntilDate = Optional.ofNullable(validUntilDate);
            return this;
        }

        public Builder validUntilDate(Nullable<String> validUntilDate) {
            if (validUntilDate.isNull()) {
                this.validUntilDate = null;
            } else if (validUntilDate.isEmpty()) {
                this.validUntilDate = Optional.empty();
            } else {
                this.validUntilDate = Optional.of(validUntilDate.get());
            }
            return this;
        }

        @JsonSetter(value = "valid_until_local_time", nulls = Nulls.SKIP)
        public Builder validUntilLocalTime(Optional<String> validUntilLocalTime) {
            this.validUntilLocalTime = validUntilLocalTime;
            return this;
        }

        public Builder validUntilLocalTime(String validUntilLocalTime) {
            this.validUntilLocalTime = Optional.ofNullable(validUntilLocalTime);
            return this;
        }

        public Builder validUntilLocalTime(Nullable<String> validUntilLocalTime) {
            if (validUntilLocalTime.isNull()) {
                this.validUntilLocalTime = null;
            } else if (validUntilLocalTime.isEmpty()) {
                this.validUntilLocalTime = Optional.empty();
            } else {
                this.validUntilLocalTime = Optional.of(validUntilLocalTime.get());
            }
            return this;
        }

        @JsonSetter(value = "exclude_strategy", nulls = Nulls.SKIP)
        public Builder excludeStrategy(Optional<ExcludeStrategy> excludeStrategy) {
            this.excludeStrategy = excludeStrategy;
            return this;
        }

        public Builder excludeStrategy(ExcludeStrategy excludeStrategy) {
            this.excludeStrategy = Optional.ofNullable(excludeStrategy);
            return this;
        }

        @JsonSetter(value = "minimum_order_subtotal_money", nulls = Nulls.SKIP)
        public Builder minimumOrderSubtotalMoney(Optional<Money> minimumOrderSubtotalMoney) {
            this.minimumOrderSubtotalMoney = minimumOrderSubtotalMoney;
            return this;
        }

        public Builder minimumOrderSubtotalMoney(Money minimumOrderSubtotalMoney) {
            this.minimumOrderSubtotalMoney = Optional.ofNullable(minimumOrderSubtotalMoney);
            return this;
        }

        @JsonSetter(value = "customer_group_ids_any", nulls = Nulls.SKIP)
        public Builder customerGroupIdsAny(Optional<List<String>> customerGroupIdsAny) {
            this.customerGroupIdsAny = customerGroupIdsAny;
            return this;
        }

        public Builder customerGroupIdsAny(List<String> customerGroupIdsAny) {
            this.customerGroupIdsAny = Optional.ofNullable(customerGroupIdsAny);
            return this;
        }

        public Builder customerGroupIdsAny(Nullable<List<String>> customerGroupIdsAny) {
            if (customerGroupIdsAny.isNull()) {
                this.customerGroupIdsAny = null;
            } else if (customerGroupIdsAny.isEmpty()) {
                this.customerGroupIdsAny = Optional.empty();
            } else {
                this.customerGroupIdsAny = Optional.of(customerGroupIdsAny.get());
            }
            return this;
        }

        public CatalogPricingRule build() {
            return new CatalogPricingRule(
                    name,
                    timePeriodIds,
                    discountId,
                    matchProductsId,
                    applyProductsId,
                    excludeProductsId,
                    validFromDate,
                    validFromLocalTime,
                    validUntilDate,
                    validUntilLocalTime,
                    excludeStrategy,
                    minimumOrderSubtotalMoney,
                    customerGroupIdsAny,
                    additionalProperties);
        }
    }
}
