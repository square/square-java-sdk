/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.squareup.square.core.Nullable;
import com.squareup.square.core.NullableNonemptyFilter;
import com.squareup.square.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ItemVariationLocationOverrides.Builder.class)
public final class ItemVariationLocationOverrides {
    private final Optional<String> locationId;

    private final Optional<Money> priceMoney;

    private final Optional<CatalogPricingType> pricingType;

    private final Optional<Boolean> trackInventory;

    private final Optional<InventoryAlertType> inventoryAlertType;

    private final Optional<Long> inventoryAlertThreshold;

    private final Optional<Boolean> soldOut;

    private final Optional<String> soldOutValidUntil;

    private final Map<String, Object> additionalProperties;

    private ItemVariationLocationOverrides(
            Optional<String> locationId,
            Optional<Money> priceMoney,
            Optional<CatalogPricingType> pricingType,
            Optional<Boolean> trackInventory,
            Optional<InventoryAlertType> inventoryAlertType,
            Optional<Long> inventoryAlertThreshold,
            Optional<Boolean> soldOut,
            Optional<String> soldOutValidUntil,
            Map<String, Object> additionalProperties) {
        this.locationId = locationId;
        this.priceMoney = priceMoney;
        this.pricingType = pricingType;
        this.trackInventory = trackInventory;
        this.inventoryAlertType = inventoryAlertType;
        this.inventoryAlertThreshold = inventoryAlertThreshold;
        this.soldOut = soldOut;
        this.soldOutValidUntil = soldOutValidUntil;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The ID of the <code>Location</code>. This can include locations that are deactivated.
     */
    @JsonIgnore
    public Optional<String> getLocationId() {
        if (locationId == null) {
            return Optional.empty();
        }
        return locationId;
    }

    /**
     * @return The price of the <code>CatalogItemVariation</code> at the given <code>Location</code>, or blank for variable pricing.
     */
    @JsonProperty("price_money")
    public Optional<Money> getPriceMoney() {
        return priceMoney;
    }

    /**
     * @return The pricing type (fixed or variable) for the <code>CatalogItemVariation</code> at the given <code>Location</code>.
     * See <a href="#type-catalogpricingtype">CatalogPricingType</a> for possible values
     */
    @JsonProperty("pricing_type")
    public Optional<CatalogPricingType> getPricingType() {
        return pricingType;
    }

    /**
     * @return If <code>true</code>, inventory tracking is active for the <code>CatalogItemVariation</code> at this <code>Location</code>.
     */
    @JsonIgnore
    public Optional<Boolean> getTrackInventory() {
        if (trackInventory == null) {
            return Optional.empty();
        }
        return trackInventory;
    }

    /**
     * @return Indicates whether the <code>CatalogItemVariation</code> displays an alert when its inventory
     * quantity is less than or equal to its <code>inventory_alert_threshold</code>.
     * See <a href="#type-inventoryalerttype">InventoryAlertType</a> for possible values
     */
    @JsonProperty("inventory_alert_type")
    public Optional<InventoryAlertType> getInventoryAlertType() {
        return inventoryAlertType;
    }

    /**
     * @return If the inventory quantity for the variation is less than or equal to this value and <code>inventory_alert_type</code>
     * is <code>LOW_QUANTITY</code>, the variation displays an alert in the merchant dashboard.
     * <p>This value is always an integer.</p>
     */
    @JsonIgnore
    public Optional<Long> getInventoryAlertThreshold() {
        if (inventoryAlertThreshold == null) {
            return Optional.empty();
        }
        return inventoryAlertThreshold;
    }

    /**
     * @return Indicates whether the overridden item variation is sold out at the specified location.
     * <p>When inventory tracking is enabled on the item variation either globally or at the specified location,
     * the item variation is automatically marked as sold out when its inventory count reaches zero. The seller
     * can manually set the item variation as sold out even when the inventory count is greater than zero.
     * Attempts by an application to set this attribute are ignored. Regardless how the sold-out status is set,
     * applications should treat its inventory count as zero when this attribute value is <code>true</code>.</p>
     */
    @JsonProperty("sold_out")
    public Optional<Boolean> getSoldOut() {
        return soldOut;
    }

    /**
     * @return The seller-assigned timestamp, of the RFC 3339 format, to indicate when this sold-out variation
     * becomes available again at the specified location. Attempts by an application to set this attribute are ignored.
     * When the current time is later than this attribute value, the affected item variation is no longer sold out.
     */
    @JsonProperty("sold_out_valid_until")
    public Optional<String> getSoldOutValidUntil() {
        return soldOutValidUntil;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("location_id")
    private Optional<String> _getLocationId() {
        return locationId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("track_inventory")
    private Optional<Boolean> _getTrackInventory() {
        return trackInventory;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("inventory_alert_threshold")
    private Optional<Long> _getInventoryAlertThreshold() {
        return inventoryAlertThreshold;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ItemVariationLocationOverrides && equalTo((ItemVariationLocationOverrides) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ItemVariationLocationOverrides other) {
        return locationId.equals(other.locationId)
                && priceMoney.equals(other.priceMoney)
                && pricingType.equals(other.pricingType)
                && trackInventory.equals(other.trackInventory)
                && inventoryAlertType.equals(other.inventoryAlertType)
                && inventoryAlertThreshold.equals(other.inventoryAlertThreshold)
                && soldOut.equals(other.soldOut)
                && soldOutValidUntil.equals(other.soldOutValidUntil);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.locationId,
                this.priceMoney,
                this.pricingType,
                this.trackInventory,
                this.inventoryAlertType,
                this.inventoryAlertThreshold,
                this.soldOut,
                this.soldOutValidUntil);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> locationId = Optional.empty();

        private Optional<Money> priceMoney = Optional.empty();

        private Optional<CatalogPricingType> pricingType = Optional.empty();

        private Optional<Boolean> trackInventory = Optional.empty();

        private Optional<InventoryAlertType> inventoryAlertType = Optional.empty();

        private Optional<Long> inventoryAlertThreshold = Optional.empty();

        private Optional<Boolean> soldOut = Optional.empty();

        private Optional<String> soldOutValidUntil = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(ItemVariationLocationOverrides other) {
            locationId(other.getLocationId());
            priceMoney(other.getPriceMoney());
            pricingType(other.getPricingType());
            trackInventory(other.getTrackInventory());
            inventoryAlertType(other.getInventoryAlertType());
            inventoryAlertThreshold(other.getInventoryAlertThreshold());
            soldOut(other.getSoldOut());
            soldOutValidUntil(other.getSoldOutValidUntil());
            return this;
        }

        /**
         * <p>The ID of the <code>Location</code>. This can include locations that are deactivated.</p>
         */
        @JsonSetter(value = "location_id", nulls = Nulls.SKIP)
        public Builder locationId(Optional<String> locationId) {
            this.locationId = locationId;
            return this;
        }

        public Builder locationId(String locationId) {
            this.locationId = Optional.ofNullable(locationId);
            return this;
        }

        public Builder locationId(Nullable<String> locationId) {
            if (locationId.isNull()) {
                this.locationId = null;
            } else if (locationId.isEmpty()) {
                this.locationId = Optional.empty();
            } else {
                this.locationId = Optional.of(locationId.get());
            }
            return this;
        }

        /**
         * <p>The price of the <code>CatalogItemVariation</code> at the given <code>Location</code>, or blank for variable pricing.</p>
         */
        @JsonSetter(value = "price_money", nulls = Nulls.SKIP)
        public Builder priceMoney(Optional<Money> priceMoney) {
            this.priceMoney = priceMoney;
            return this;
        }

        public Builder priceMoney(Money priceMoney) {
            this.priceMoney = Optional.ofNullable(priceMoney);
            return this;
        }

        /**
         * <p>The pricing type (fixed or variable) for the <code>CatalogItemVariation</code> at the given <code>Location</code>.
         * See <a href="#type-catalogpricingtype">CatalogPricingType</a> for possible values</p>
         */
        @JsonSetter(value = "pricing_type", nulls = Nulls.SKIP)
        public Builder pricingType(Optional<CatalogPricingType> pricingType) {
            this.pricingType = pricingType;
            return this;
        }

        public Builder pricingType(CatalogPricingType pricingType) {
            this.pricingType = Optional.ofNullable(pricingType);
            return this;
        }

        /**
         * <p>If <code>true</code>, inventory tracking is active for the <code>CatalogItemVariation</code> at this <code>Location</code>.</p>
         */
        @JsonSetter(value = "track_inventory", nulls = Nulls.SKIP)
        public Builder trackInventory(Optional<Boolean> trackInventory) {
            this.trackInventory = trackInventory;
            return this;
        }

        public Builder trackInventory(Boolean trackInventory) {
            this.trackInventory = Optional.ofNullable(trackInventory);
            return this;
        }

        public Builder trackInventory(Nullable<Boolean> trackInventory) {
            if (trackInventory.isNull()) {
                this.trackInventory = null;
            } else if (trackInventory.isEmpty()) {
                this.trackInventory = Optional.empty();
            } else {
                this.trackInventory = Optional.of(trackInventory.get());
            }
            return this;
        }

        /**
         * <p>Indicates whether the <code>CatalogItemVariation</code> displays an alert when its inventory
         * quantity is less than or equal to its <code>inventory_alert_threshold</code>.
         * See <a href="#type-inventoryalerttype">InventoryAlertType</a> for possible values</p>
         */
        @JsonSetter(value = "inventory_alert_type", nulls = Nulls.SKIP)
        public Builder inventoryAlertType(Optional<InventoryAlertType> inventoryAlertType) {
            this.inventoryAlertType = inventoryAlertType;
            return this;
        }

        public Builder inventoryAlertType(InventoryAlertType inventoryAlertType) {
            this.inventoryAlertType = Optional.ofNullable(inventoryAlertType);
            return this;
        }

        /**
         * <p>If the inventory quantity for the variation is less than or equal to this value and <code>inventory_alert_type</code>
         * is <code>LOW_QUANTITY</code>, the variation displays an alert in the merchant dashboard.</p>
         * <p>This value is always an integer.</p>
         */
        @JsonSetter(value = "inventory_alert_threshold", nulls = Nulls.SKIP)
        public Builder inventoryAlertThreshold(Optional<Long> inventoryAlertThreshold) {
            this.inventoryAlertThreshold = inventoryAlertThreshold;
            return this;
        }

        public Builder inventoryAlertThreshold(Long inventoryAlertThreshold) {
            this.inventoryAlertThreshold = Optional.ofNullable(inventoryAlertThreshold);
            return this;
        }

        public Builder inventoryAlertThreshold(Nullable<Long> inventoryAlertThreshold) {
            if (inventoryAlertThreshold.isNull()) {
                this.inventoryAlertThreshold = null;
            } else if (inventoryAlertThreshold.isEmpty()) {
                this.inventoryAlertThreshold = Optional.empty();
            } else {
                this.inventoryAlertThreshold = Optional.of(inventoryAlertThreshold.get());
            }
            return this;
        }

        /**
         * <p>Indicates whether the overridden item variation is sold out at the specified location.</p>
         * <p>When inventory tracking is enabled on the item variation either globally or at the specified location,
         * the item variation is automatically marked as sold out when its inventory count reaches zero. The seller
         * can manually set the item variation as sold out even when the inventory count is greater than zero.
         * Attempts by an application to set this attribute are ignored. Regardless how the sold-out status is set,
         * applications should treat its inventory count as zero when this attribute value is <code>true</code>.</p>
         */
        @JsonSetter(value = "sold_out", nulls = Nulls.SKIP)
        public Builder soldOut(Optional<Boolean> soldOut) {
            this.soldOut = soldOut;
            return this;
        }

        public Builder soldOut(Boolean soldOut) {
            this.soldOut = Optional.ofNullable(soldOut);
            return this;
        }

        /**
         * <p>The seller-assigned timestamp, of the RFC 3339 format, to indicate when this sold-out variation
         * becomes available again at the specified location. Attempts by an application to set this attribute are ignored.
         * When the current time is later than this attribute value, the affected item variation is no longer sold out.</p>
         */
        @JsonSetter(value = "sold_out_valid_until", nulls = Nulls.SKIP)
        public Builder soldOutValidUntil(Optional<String> soldOutValidUntil) {
            this.soldOutValidUntil = soldOutValidUntil;
            return this;
        }

        public Builder soldOutValidUntil(String soldOutValidUntil) {
            this.soldOutValidUntil = Optional.ofNullable(soldOutValidUntil);
            return this;
        }

        public ItemVariationLocationOverrides build() {
            return new ItemVariationLocationOverrides(
                    locationId,
                    priceMoney,
                    pricingType,
                    trackInventory,
                    inventoryAlertType,
                    inventoryAlertThreshold,
                    soldOut,
                    soldOutValidUntil,
                    additionalProperties);
        }
    }
}
