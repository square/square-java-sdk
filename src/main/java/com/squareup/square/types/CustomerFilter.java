/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.squareup.square.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = CustomerFilter.Builder.class)
public final class CustomerFilter {
    private final Optional<CustomerCreationSourceFilter> creationSource;

    private final Optional<TimeRange> createdAt;

    private final Optional<TimeRange> updatedAt;

    private final Optional<CustomerTextFilter> emailAddress;

    private final Optional<CustomerTextFilter> phoneNumber;

    private final Optional<CustomerTextFilter> referenceId;

    private final Optional<FilterValue> groupIds;

    private final Optional<CustomerCustomAttributeFilters> customAttribute;

    private final Optional<FilterValue> segmentIds;

    private final Map<String, Object> additionalProperties;

    private CustomerFilter(
            Optional<CustomerCreationSourceFilter> creationSource,
            Optional<TimeRange> createdAt,
            Optional<TimeRange> updatedAt,
            Optional<CustomerTextFilter> emailAddress,
            Optional<CustomerTextFilter> phoneNumber,
            Optional<CustomerTextFilter> referenceId,
            Optional<FilterValue> groupIds,
            Optional<CustomerCustomAttributeFilters> customAttribute,
            Optional<FilterValue> segmentIds,
            Map<String, Object> additionalProperties) {
        this.creationSource = creationSource;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.emailAddress = emailAddress;
        this.phoneNumber = phoneNumber;
        this.referenceId = referenceId;
        this.groupIds = groupIds;
        this.customAttribute = customAttribute;
        this.segmentIds = segmentIds;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return A filter to select customers based on their creation source.
     */
    @JsonProperty("creation_source")
    public Optional<CustomerCreationSourceFilter> getCreationSource() {
        return creationSource;
    }

    /**
     * @return A filter to select customers based on when they were created.
     */
    @JsonProperty("created_at")
    public Optional<TimeRange> getCreatedAt() {
        return createdAt;
    }

    /**
     * @return A filter to select customers based on when they were last updated.
     */
    @JsonProperty("updated_at")
    public Optional<TimeRange> getUpdatedAt() {
        return updatedAt;
    }

    /**
     * @return A filter to <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-email-address">select customers by their email address</a>
     * visible to the seller.
     * This filter is case-insensitive.
     * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-email-address">exact matching</a>, this
     * filter causes the search to return customer profiles
     * whose <code>email_address</code> field value are identical to the email address provided
     * in the query.</p>
     * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-email-address">fuzzy matching</a>,
     * this filter causes the search to return customer profiles
     * whose <code>email_address</code> field value has a token-wise partial match against the filtering
     * expression in the query. For example, with <code>Steven gmail</code> provided in a search
     * query, the search returns customers whose email address is <code>steven.johnson@gmail.com</code>
     * or <code>mygmail@stevensbakery.com</code>. Square removes any punctuation (including periods (.),
     * underscores (_), and the @ symbol) and tokenizes the email addresses on spaces. A match is
     * found if a tokenized email address contains all the tokens in the search query,
     * irrespective of the token order.</p>
     */
    @JsonProperty("email_address")
    public Optional<CustomerTextFilter> getEmailAddress() {
        return emailAddress;
    }

    /**
     * @return A filter to <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-phone-number">select customers by their phone numbers</a>
     * visible to the seller.
     * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-phone-number">exact matching</a>,
     * this filter returns customers whose phone number matches the specified query expression. The number in the query must be of an
     * E.164-compliant form. In particular, it must include the leading <code>+</code> sign followed by a country code and then a subscriber number.
     * For example, the standard E.164 form of a US phone number is <code>+12062223333</code> and an E.164-compliant variation is <code>+1 (206) 222-3333</code>.
     * To match the query expression, stored customer phone numbers are converted to the standard E.164 form.</p>
     * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-phone-number">fuzzy matching</a>,
     * this filter returns customers whose phone number matches the token or tokens provided in the query expression. For example, with <code>415</code>
     * provided in a search query, the search returns customers with the phone numbers <code>+1-415-212-1200</code>, <code>+1-212-415-1234</code>, and <code>+1 (551) 234-1567</code>.
     * Similarly, a search query of <code>415 123</code> returns customers with the phone numbers <code>+1-212-415-1234</code> and <code>+1 (551) 234-1567</code> but not
     * <code>+1-212-415-1200</code>. A match is found if a tokenized phone number contains all the tokens in the search query, irrespective of the token order.</p>
     */
    @JsonProperty("phone_number")
    public Optional<CustomerTextFilter> getPhoneNumber() {
        return phoneNumber;
    }

    /**
     * @return A filter to <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-reference-id">select customers by their reference IDs</a>.
     * This filter is case-insensitive.
     * <p><a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-reference-id">Exact matching</a>
     * of a customer's reference ID against a query's reference ID is evaluated as an
     * exact match between two strings, character by character in the given order.</p>
     * <p><a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-reference-id">Fuzzy matching</a>
     * of stored reference IDs against queried reference IDs works
     * exactly the same as fuzzy matching on email addresses. Non-alphanumeric characters
     * are replaced by spaces to tokenize stored and queried reference IDs. A match is found
     * if a tokenized stored reference ID contains all tokens specified in any order in the query. For example,
     * a query of <code>NYC M</code> matches customer profiles with the <code>reference_id</code> value of <code>NYC_M_35_JOHNSON</code>
     * and <code>NYC_27_MURRAY</code>.</p>
     */
    @JsonProperty("reference_id")
    public Optional<CustomerTextFilter> getReferenceId() {
        return referenceId;
    }

    /**
     * @return A filter to select customers based on the <a href="entity:CustomerGroup">groups</a> they belong to.
     * Group membership is controlled by sellers and developers.
     * <p>The <code>group_ids</code> filter has the following syntax:</p>
     * <pre><code>&quot;group_ids&quot;: {
     * &quot;any&quot;:  [&quot;{group_a_id}&quot;, &quot;{group_b_id}&quot;, ...],
     * &quot;all&quot;:  [&quot;{group_1_id}&quot;, &quot;{group_2_id}&quot;, ...],
     * &quot;none&quot;: [&quot;{group_i_id}&quot;, &quot;{group_ii_id}&quot;, ...]
     * }
     * </code></pre>
     * <p>You can use any combination of the <code>any</code>, <code>all</code>, and <code>none</code> fields in the filter.
     * With <code>any</code>, the search returns customers in groups <code>a</code> or <code>b</code> or any other group specified in the list.
     * With <code>all</code>, the search returns customers in groups <code>1</code> and <code>2</code> and all other groups specified in the list.
     * With <code>none</code>, the search returns customers not in groups <code>i</code> or <code>ii</code> or any other group specified in the list.</p>
     * <p>If any of the search conditions are not met, including when an invalid or non-existent group ID is provided,
     * the result is an empty object (<code>{}</code>).</p>
     */
    @JsonProperty("group_ids")
    public Optional<FilterValue> getGroupIds() {
        return groupIds;
    }

    /**
     * @return A filter to select customers based on one or more custom attributes.
     * This filter can contain up to 10 custom attribute filters. Each custom attribute filter specifies filtering criteria for a target custom
     * attribute. If multiple custom attribute filters are provided, they are combined as an <code>AND</code> operation.
     * <p>To be valid for a search, the custom attributes must be visible to the requesting application. For more information, including example queries,
     * see <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-custom-attribute">Search by custom attribute</a>.</p>
     * <p>Square returns matching customer profiles, which do not contain custom attributes. To retrieve customer-related custom attributes,
     * use the <a href="api:CustomerCustomAttributes">Customer Custom Attributes API</a>. For example, you can call
     * <a href="api-endpoint:CustomerCustomAttributes-RetrieveCustomerCustomAttribute">RetrieveCustomerCustomAttribute</a> using a customer ID from the result set.</p>
     */
    @JsonProperty("custom_attribute")
    public Optional<CustomerCustomAttributeFilters> getCustomAttribute() {
        return customAttribute;
    }

    /**
     * @return A filter to select customers based on the <a href="entity:CustomerSegment">segments</a> they belong to.
     * Segment membership is dynamic and adjusts automatically based on whether customers meet the segment criteria.
     * <p>You can provide up to three segment IDs in the filter, using any combination of the <code>all</code>, <code>any</code>, and <code>none</code> fields.
     * For the following example, the results include customers who belong to both segment A and segment B but do not belong to segment C.</p>
     * <pre><code>&quot;segment_ids&quot;: {
     * &quot;all&quot;:  [&quot;{segment_A_id}&quot;, &quot;{segment_B_id}&quot;],
     * &quot;none&quot;:  [&quot;{segment_C_id}&quot;]
     * }
     * </code></pre>
     * <p>If an invalid or non-existent segment ID is provided in the filter, Square stops processing the request
     * and returns a <code>400 BAD_REQUEST</code> error that includes the segment ID.</p>
     */
    @JsonProperty("segment_ids")
    public Optional<FilterValue> getSegmentIds() {
        return segmentIds;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof CustomerFilter && equalTo((CustomerFilter) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(CustomerFilter other) {
        return creationSource.equals(other.creationSource)
                && createdAt.equals(other.createdAt)
                && updatedAt.equals(other.updatedAt)
                && emailAddress.equals(other.emailAddress)
                && phoneNumber.equals(other.phoneNumber)
                && referenceId.equals(other.referenceId)
                && groupIds.equals(other.groupIds)
                && customAttribute.equals(other.customAttribute)
                && segmentIds.equals(other.segmentIds);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.creationSource,
                this.createdAt,
                this.updatedAt,
                this.emailAddress,
                this.phoneNumber,
                this.referenceId,
                this.groupIds,
                this.customAttribute,
                this.segmentIds);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<CustomerCreationSourceFilter> creationSource = Optional.empty();

        private Optional<TimeRange> createdAt = Optional.empty();

        private Optional<TimeRange> updatedAt = Optional.empty();

        private Optional<CustomerTextFilter> emailAddress = Optional.empty();

        private Optional<CustomerTextFilter> phoneNumber = Optional.empty();

        private Optional<CustomerTextFilter> referenceId = Optional.empty();

        private Optional<FilterValue> groupIds = Optional.empty();

        private Optional<CustomerCustomAttributeFilters> customAttribute = Optional.empty();

        private Optional<FilterValue> segmentIds = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(CustomerFilter other) {
            creationSource(other.getCreationSource());
            createdAt(other.getCreatedAt());
            updatedAt(other.getUpdatedAt());
            emailAddress(other.getEmailAddress());
            phoneNumber(other.getPhoneNumber());
            referenceId(other.getReferenceId());
            groupIds(other.getGroupIds());
            customAttribute(other.getCustomAttribute());
            segmentIds(other.getSegmentIds());
            return this;
        }

        /**
         * <p>A filter to select customers based on their creation source.</p>
         */
        @JsonSetter(value = "creation_source", nulls = Nulls.SKIP)
        public Builder creationSource(Optional<CustomerCreationSourceFilter> creationSource) {
            this.creationSource = creationSource;
            return this;
        }

        public Builder creationSource(CustomerCreationSourceFilter creationSource) {
            this.creationSource = Optional.ofNullable(creationSource);
            return this;
        }

        /**
         * <p>A filter to select customers based on when they were created.</p>
         */
        @JsonSetter(value = "created_at", nulls = Nulls.SKIP)
        public Builder createdAt(Optional<TimeRange> createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        public Builder createdAt(TimeRange createdAt) {
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * <p>A filter to select customers based on when they were last updated.</p>
         */
        @JsonSetter(value = "updated_at", nulls = Nulls.SKIP)
        public Builder updatedAt(Optional<TimeRange> updatedAt) {
            this.updatedAt = updatedAt;
            return this;
        }

        public Builder updatedAt(TimeRange updatedAt) {
            this.updatedAt = Optional.ofNullable(updatedAt);
            return this;
        }

        /**
         * <p>A filter to <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-email-address">select customers by their email address</a>
         * visible to the seller.
         * This filter is case-insensitive.</p>
         * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-email-address">exact matching</a>, this
         * filter causes the search to return customer profiles
         * whose <code>email_address</code> field value are identical to the email address provided
         * in the query.</p>
         * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-email-address">fuzzy matching</a>,
         * this filter causes the search to return customer profiles
         * whose <code>email_address</code> field value has a token-wise partial match against the filtering
         * expression in the query. For example, with <code>Steven gmail</code> provided in a search
         * query, the search returns customers whose email address is <code>steven.johnson@gmail.com</code>
         * or <code>mygmail@stevensbakery.com</code>. Square removes any punctuation (including periods (.),
         * underscores (_), and the @ symbol) and tokenizes the email addresses on spaces. A match is
         * found if a tokenized email address contains all the tokens in the search query,
         * irrespective of the token order.</p>
         */
        @JsonSetter(value = "email_address", nulls = Nulls.SKIP)
        public Builder emailAddress(Optional<CustomerTextFilter> emailAddress) {
            this.emailAddress = emailAddress;
            return this;
        }

        public Builder emailAddress(CustomerTextFilter emailAddress) {
            this.emailAddress = Optional.ofNullable(emailAddress);
            return this;
        }

        /**
         * <p>A filter to <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-phone-number">select customers by their phone numbers</a>
         * visible to the seller.</p>
         * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-phone-number">exact matching</a>,
         * this filter returns customers whose phone number matches the specified query expression. The number in the query must be of an
         * E.164-compliant form. In particular, it must include the leading <code>+</code> sign followed by a country code and then a subscriber number.
         * For example, the standard E.164 form of a US phone number is <code>+12062223333</code> and an E.164-compliant variation is <code>+1 (206) 222-3333</code>.
         * To match the query expression, stored customer phone numbers are converted to the standard E.164 form.</p>
         * <p>For <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-phone-number">fuzzy matching</a>,
         * this filter returns customers whose phone number matches the token or tokens provided in the query expression. For example, with <code>415</code>
         * provided in a search query, the search returns customers with the phone numbers <code>+1-415-212-1200</code>, <code>+1-212-415-1234</code>, and <code>+1 (551) 234-1567</code>.
         * Similarly, a search query of <code>415 123</code> returns customers with the phone numbers <code>+1-212-415-1234</code> and <code>+1 (551) 234-1567</code> but not
         * <code>+1-212-415-1200</code>. A match is found if a tokenized phone number contains all the tokens in the search query, irrespective of the token order.</p>
         */
        @JsonSetter(value = "phone_number", nulls = Nulls.SKIP)
        public Builder phoneNumber(Optional<CustomerTextFilter> phoneNumber) {
            this.phoneNumber = phoneNumber;
            return this;
        }

        public Builder phoneNumber(CustomerTextFilter phoneNumber) {
            this.phoneNumber = Optional.ofNullable(phoneNumber);
            return this;
        }

        /**
         * <p>A filter to <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-reference-id">select customers by their reference IDs</a>.
         * This filter is case-insensitive.</p>
         * <p><a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-reference-id">Exact matching</a>
         * of a customer's reference ID against a query's reference ID is evaluated as an
         * exact match between two strings, character by character in the given order.</p>
         * <p><a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-reference-id">Fuzzy matching</a>
         * of stored reference IDs against queried reference IDs works
         * exactly the same as fuzzy matching on email addresses. Non-alphanumeric characters
         * are replaced by spaces to tokenize stored and queried reference IDs. A match is found
         * if a tokenized stored reference ID contains all tokens specified in any order in the query. For example,
         * a query of <code>NYC M</code> matches customer profiles with the <code>reference_id</code> value of <code>NYC_M_35_JOHNSON</code>
         * and <code>NYC_27_MURRAY</code>.</p>
         */
        @JsonSetter(value = "reference_id", nulls = Nulls.SKIP)
        public Builder referenceId(Optional<CustomerTextFilter> referenceId) {
            this.referenceId = referenceId;
            return this;
        }

        public Builder referenceId(CustomerTextFilter referenceId) {
            this.referenceId = Optional.ofNullable(referenceId);
            return this;
        }

        /**
         * <p>A filter to select customers based on the <a href="entity:CustomerGroup">groups</a> they belong to.
         * Group membership is controlled by sellers and developers.</p>
         * <p>The <code>group_ids</code> filter has the following syntax:</p>
         * <pre><code>&quot;group_ids&quot;: {
         * &quot;any&quot;:  [&quot;{group_a_id}&quot;, &quot;{group_b_id}&quot;, ...],
         * &quot;all&quot;:  [&quot;{group_1_id}&quot;, &quot;{group_2_id}&quot;, ...],
         * &quot;none&quot;: [&quot;{group_i_id}&quot;, &quot;{group_ii_id}&quot;, ...]
         * }
         * </code></pre>
         * <p>You can use any combination of the <code>any</code>, <code>all</code>, and <code>none</code> fields in the filter.
         * With <code>any</code>, the search returns customers in groups <code>a</code> or <code>b</code> or any other group specified in the list.
         * With <code>all</code>, the search returns customers in groups <code>1</code> and <code>2</code> and all other groups specified in the list.
         * With <code>none</code>, the search returns customers not in groups <code>i</code> or <code>ii</code> or any other group specified in the list.</p>
         * <p>If any of the search conditions are not met, including when an invalid or non-existent group ID is provided,
         * the result is an empty object (<code>{}</code>).</p>
         */
        @JsonSetter(value = "group_ids", nulls = Nulls.SKIP)
        public Builder groupIds(Optional<FilterValue> groupIds) {
            this.groupIds = groupIds;
            return this;
        }

        public Builder groupIds(FilterValue groupIds) {
            this.groupIds = Optional.ofNullable(groupIds);
            return this;
        }

        /**
         * <p>A filter to select customers based on one or more custom attributes.
         * This filter can contain up to 10 custom attribute filters. Each custom attribute filter specifies filtering criteria for a target custom
         * attribute. If multiple custom attribute filters are provided, they are combined as an <code>AND</code> operation.</p>
         * <p>To be valid for a search, the custom attributes must be visible to the requesting application. For more information, including example queries,
         * see <a href="https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-custom-attribute">Search by custom attribute</a>.</p>
         * <p>Square returns matching customer profiles, which do not contain custom attributes. To retrieve customer-related custom attributes,
         * use the <a href="api:CustomerCustomAttributes">Customer Custom Attributes API</a>. For example, you can call
         * <a href="api-endpoint:CustomerCustomAttributes-RetrieveCustomerCustomAttribute">RetrieveCustomerCustomAttribute</a> using a customer ID from the result set.</p>
         */
        @JsonSetter(value = "custom_attribute", nulls = Nulls.SKIP)
        public Builder customAttribute(Optional<CustomerCustomAttributeFilters> customAttribute) {
            this.customAttribute = customAttribute;
            return this;
        }

        public Builder customAttribute(CustomerCustomAttributeFilters customAttribute) {
            this.customAttribute = Optional.ofNullable(customAttribute);
            return this;
        }

        /**
         * <p>A filter to select customers based on the <a href="entity:CustomerSegment">segments</a> they belong to.
         * Segment membership is dynamic and adjusts automatically based on whether customers meet the segment criteria.</p>
         * <p>You can provide up to three segment IDs in the filter, using any combination of the <code>all</code>, <code>any</code>, and <code>none</code> fields.
         * For the following example, the results include customers who belong to both segment A and segment B but do not belong to segment C.</p>
         * <pre><code>&quot;segment_ids&quot;: {
         * &quot;all&quot;:  [&quot;{segment_A_id}&quot;, &quot;{segment_B_id}&quot;],
         * &quot;none&quot;:  [&quot;{segment_C_id}&quot;]
         * }
         * </code></pre>
         * <p>If an invalid or non-existent segment ID is provided in the filter, Square stops processing the request
         * and returns a <code>400 BAD_REQUEST</code> error that includes the segment ID.</p>
         */
        @JsonSetter(value = "segment_ids", nulls = Nulls.SKIP)
        public Builder segmentIds(Optional<FilterValue> segmentIds) {
            this.segmentIds = segmentIds;
            return this;
        }

        public Builder segmentIds(FilterValue segmentIds) {
            this.segmentIds = Optional.ofNullable(segmentIds);
            return this;
        }

        public CustomerFilter build() {
            return new CustomerFilter(
                    creationSource,
                    createdAt,
                    updatedAt,
                    emailAddress,
                    phoneNumber,
                    referenceId,
                    groupIds,
                    customAttribute,
                    segmentIds,
                    additionalProperties);
        }
    }
}
