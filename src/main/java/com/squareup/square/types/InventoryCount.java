/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.squareup.square.core.Nullable;
import com.squareup.square.core.NullableNonemptyFilter;
import com.squareup.square.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = InventoryCount.Builder.class)
public final class InventoryCount {
    private final Optional<String> catalogObjectId;

    private final Optional<String> catalogObjectType;

    private final Optional<InventoryState> state;

    private final Optional<String> locationId;

    private final Optional<String> quantity;

    private final Optional<String> calculatedAt;

    private final Optional<Boolean> isEstimated;

    private final Map<String, Object> additionalProperties;

    private InventoryCount(
            Optional<String> catalogObjectId,
            Optional<String> catalogObjectType,
            Optional<InventoryState> state,
            Optional<String> locationId,
            Optional<String> quantity,
            Optional<String> calculatedAt,
            Optional<Boolean> isEstimated,
            Map<String, Object> additionalProperties) {
        this.catalogObjectId = catalogObjectId;
        this.catalogObjectType = catalogObjectType;
        this.state = state;
        this.locationId = locationId;
        this.quantity = quantity;
        this.calculatedAt = calculatedAt;
        this.isEstimated = isEstimated;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The Square-generated ID of the
     * <a href="entity:CatalogObject">CatalogObject</a> being tracked.
     */
    @JsonIgnore
    public Optional<String> getCatalogObjectId() {
        if (catalogObjectId == null) {
            return Optional.empty();
        }
        return catalogObjectId;
    }

    /**
     * @return The <a href="entity:CatalogObjectType">type</a> of the <a href="entity:CatalogObject">CatalogObject</a> being tracked.
     * <p>The Inventory API supports setting and reading the <code>&quot;catalog_object_type&quot;: &quot;ITEM_VARIATION&quot;</code> field value.
     * In addition, it can also read the <code>&quot;catalog_object_type&quot;: &quot;ITEM&quot;</code> field value that is set by the Square Restaurants app.</p>
     */
    @JsonIgnore
    public Optional<String> getCatalogObjectType() {
        if (catalogObjectType == null) {
            return Optional.empty();
        }
        return catalogObjectType;
    }

    /**
     * @return The current <a href="entity:InventoryState">inventory state</a> for the related
     * quantity of items.
     * See <a href="#type-inventorystate">InventoryState</a> for possible values
     */
    @JsonProperty("state")
    public Optional<InventoryState> getState() {
        return state;
    }

    /**
     * @return The Square-generated ID of the <a href="entity:Location">Location</a> where the related
     * quantity of items is being tracked.
     */
    @JsonIgnore
    public Optional<String> getLocationId() {
        if (locationId == null) {
            return Optional.empty();
        }
        return locationId;
    }

    /**
     * @return The number of items affected by the estimated count as a decimal string.
     * Can support up to 5 digits after the decimal point.
     */
    @JsonIgnore
    public Optional<String> getQuantity() {
        if (quantity == null) {
            return Optional.empty();
        }
        return quantity;
    }

    /**
     * @return An RFC 3339-formatted timestamp that indicates when the most recent physical count or adjustment affecting
     * the estimated count is received.
     */
    @JsonProperty("calculated_at")
    public Optional<String> getCalculatedAt() {
        return calculatedAt;
    }

    /**
     * @return Whether the inventory count is for composed variation (TRUE) or not (FALSE). If true, the inventory count will not be present in the response of
     * any of these endpoints: <a href="api-endpoint:Inventory-BatchChangeInventory">BatchChangeInventory</a>,
     * <a href="api-endpoint:Inventory-BatchRetrieveInventoryChanges">BatchRetrieveInventoryChanges</a>,
     * <a href="api-endpoint:Inventory-BatchRetrieveInventoryCounts">BatchRetrieveInventoryCounts</a>, and
     * <a href="api-endpoint:Inventory-RetrieveInventoryChanges">RetrieveInventoryChanges</a>.
     */
    @JsonProperty("is_estimated")
    public Optional<Boolean> getIsEstimated() {
        return isEstimated;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("catalog_object_id")
    private Optional<String> _getCatalogObjectId() {
        return catalogObjectId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("catalog_object_type")
    private Optional<String> _getCatalogObjectType() {
        return catalogObjectType;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("location_id")
    private Optional<String> _getLocationId() {
        return locationId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("quantity")
    private Optional<String> _getQuantity() {
        return quantity;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof InventoryCount && equalTo((InventoryCount) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(InventoryCount other) {
        return catalogObjectId.equals(other.catalogObjectId)
                && catalogObjectType.equals(other.catalogObjectType)
                && state.equals(other.state)
                && locationId.equals(other.locationId)
                && quantity.equals(other.quantity)
                && calculatedAt.equals(other.calculatedAt)
                && isEstimated.equals(other.isEstimated);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.catalogObjectId,
                this.catalogObjectType,
                this.state,
                this.locationId,
                this.quantity,
                this.calculatedAt,
                this.isEstimated);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> catalogObjectId = Optional.empty();

        private Optional<String> catalogObjectType = Optional.empty();

        private Optional<InventoryState> state = Optional.empty();

        private Optional<String> locationId = Optional.empty();

        private Optional<String> quantity = Optional.empty();

        private Optional<String> calculatedAt = Optional.empty();

        private Optional<Boolean> isEstimated = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(InventoryCount other) {
            catalogObjectId(other.getCatalogObjectId());
            catalogObjectType(other.getCatalogObjectType());
            state(other.getState());
            locationId(other.getLocationId());
            quantity(other.getQuantity());
            calculatedAt(other.getCalculatedAt());
            isEstimated(other.getIsEstimated());
            return this;
        }

        @JsonSetter(value = "catalog_object_id", nulls = Nulls.SKIP)
        public Builder catalogObjectId(Optional<String> catalogObjectId) {
            this.catalogObjectId = catalogObjectId;
            return this;
        }

        public Builder catalogObjectId(String catalogObjectId) {
            this.catalogObjectId = Optional.ofNullable(catalogObjectId);
            return this;
        }

        public Builder catalogObjectId(Nullable<String> catalogObjectId) {
            if (catalogObjectId.isNull()) {
                this.catalogObjectId = null;
            } else if (catalogObjectId.isEmpty()) {
                this.catalogObjectId = Optional.empty();
            } else {
                this.catalogObjectId = Optional.of(catalogObjectId.get());
            }
            return this;
        }

        @JsonSetter(value = "catalog_object_type", nulls = Nulls.SKIP)
        public Builder catalogObjectType(Optional<String> catalogObjectType) {
            this.catalogObjectType = catalogObjectType;
            return this;
        }

        public Builder catalogObjectType(String catalogObjectType) {
            this.catalogObjectType = Optional.ofNullable(catalogObjectType);
            return this;
        }

        public Builder catalogObjectType(Nullable<String> catalogObjectType) {
            if (catalogObjectType.isNull()) {
                this.catalogObjectType = null;
            } else if (catalogObjectType.isEmpty()) {
                this.catalogObjectType = Optional.empty();
            } else {
                this.catalogObjectType = Optional.of(catalogObjectType.get());
            }
            return this;
        }

        @JsonSetter(value = "state", nulls = Nulls.SKIP)
        public Builder state(Optional<InventoryState> state) {
            this.state = state;
            return this;
        }

        public Builder state(InventoryState state) {
            this.state = Optional.ofNullable(state);
            return this;
        }

        @JsonSetter(value = "location_id", nulls = Nulls.SKIP)
        public Builder locationId(Optional<String> locationId) {
            this.locationId = locationId;
            return this;
        }

        public Builder locationId(String locationId) {
            this.locationId = Optional.ofNullable(locationId);
            return this;
        }

        public Builder locationId(Nullable<String> locationId) {
            if (locationId.isNull()) {
                this.locationId = null;
            } else if (locationId.isEmpty()) {
                this.locationId = Optional.empty();
            } else {
                this.locationId = Optional.of(locationId.get());
            }
            return this;
        }

        @JsonSetter(value = "quantity", nulls = Nulls.SKIP)
        public Builder quantity(Optional<String> quantity) {
            this.quantity = quantity;
            return this;
        }

        public Builder quantity(String quantity) {
            this.quantity = Optional.ofNullable(quantity);
            return this;
        }

        public Builder quantity(Nullable<String> quantity) {
            if (quantity.isNull()) {
                this.quantity = null;
            } else if (quantity.isEmpty()) {
                this.quantity = Optional.empty();
            } else {
                this.quantity = Optional.of(quantity.get());
            }
            return this;
        }

        @JsonSetter(value = "calculated_at", nulls = Nulls.SKIP)
        public Builder calculatedAt(Optional<String> calculatedAt) {
            this.calculatedAt = calculatedAt;
            return this;
        }

        public Builder calculatedAt(String calculatedAt) {
            this.calculatedAt = Optional.ofNullable(calculatedAt);
            return this;
        }

        @JsonSetter(value = "is_estimated", nulls = Nulls.SKIP)
        public Builder isEstimated(Optional<Boolean> isEstimated) {
            this.isEstimated = isEstimated;
            return this;
        }

        public Builder isEstimated(Boolean isEstimated) {
            this.isEstimated = Optional.ofNullable(isEstimated);
            return this;
        }

        public InventoryCount build() {
            return new InventoryCount(
                    catalogObjectId,
                    catalogObjectType,
                    state,
                    locationId,
                    quantity,
                    calculatedAt,
                    isEstimated,
                    additionalProperties);
        }
    }
}
