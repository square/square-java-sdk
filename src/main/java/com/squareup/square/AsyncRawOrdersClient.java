/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.squareup.square;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.squareup.square.core.ClientOptions;
import com.squareup.square.core.MediaTypes;
import com.squareup.square.core.ObjectMappers;
import com.squareup.square.core.RequestOptions;
import com.squareup.square.core.SquareApiException;
import com.squareup.square.core.SquareClientHttpResponse;
import com.squareup.square.core.SquareException;
import com.squareup.square.types.BatchGetOrdersRequest;
import com.squareup.square.types.BatchGetOrdersResponse;
import com.squareup.square.types.CalculateOrderRequest;
import com.squareup.square.types.CalculateOrderResponse;
import com.squareup.square.types.CloneOrderRequest;
import com.squareup.square.types.CloneOrderResponse;
import com.squareup.square.types.CreateOrderRequest;
import com.squareup.square.types.CreateOrderResponse;
import com.squareup.square.types.GetOrderResponse;
import com.squareup.square.types.GetOrdersRequest;
import com.squareup.square.types.PayOrderRequest;
import com.squareup.square.types.PayOrderResponse;
import com.squareup.square.types.SearchOrdersRequest;
import com.squareup.square.types.SearchOrdersResponse;
import com.squareup.square.types.UpdateOrderRequest;
import com.squareup.square.types.UpdateOrderResponse;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawOrdersClient {
    protected final ClientOptions clientOptions;

    public AsyncRawOrdersClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Creates a new <a href="entity:Order">order</a> that can include information about products for
     * purchase and settings to apply to the purchase.
     * <p>To pay for a created order, see
     * <a href="https://developer.squareup.com/docs/orders-api/pay-for-orders">Pay for Orders</a>.</p>
     * <p>You can modify open orders using the <a href="api-endpoint:Orders-UpdateOrder">UpdateOrder</a> endpoint.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<CreateOrderResponse>> create() {
        return create(CreateOrderRequest.builder().build());
    }

    /**
     * Creates a new <a href="entity:Order">order</a> that can include information about products for
     * purchase and settings to apply to the purchase.
     * <p>To pay for a created order, see
     * <a href="https://developer.squareup.com/docs/orders-api/pay-for-orders">Pay for Orders</a>.</p>
     * <p>You can modify open orders using the <a href="api-endpoint:Orders-UpdateOrder">UpdateOrder</a> endpoint.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<CreateOrderResponse>> create(RequestOptions requestOptions) {
        return create(CreateOrderRequest.builder().build(), requestOptions);
    }

    /**
     * Creates a new <a href="entity:Order">order</a> that can include information about products for
     * purchase and settings to apply to the purchase.
     * <p>To pay for a created order, see
     * <a href="https://developer.squareup.com/docs/orders-api/pay-for-orders">Pay for Orders</a>.</p>
     * <p>You can modify open orders using the <a href="api-endpoint:Orders-UpdateOrder">UpdateOrder</a> endpoint.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<CreateOrderResponse>> create(CreateOrderRequest request) {
        return create(request, null);
    }

    /**
     * Creates a new <a href="entity:Order">order</a> that can include information about products for
     * purchase and settings to apply to the purchase.
     * <p>To pay for a created order, see
     * <a href="https://developer.squareup.com/docs/orders-api/pay-for-orders">Pay for Orders</a>.</p>
     * <p>You can modify open orders using the <a href="api-endpoint:Orders-UpdateOrder">UpdateOrder</a> endpoint.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<CreateOrderResponse>> create(
            CreateOrderRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<CreateOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, CreateOrderResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Retrieves a set of <a href="entity:Order">orders</a> by their IDs.
     * <p>If a given order ID does not exist, the ID is ignored instead of generating an error.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<BatchGetOrdersResponse>> batchGet(BatchGetOrdersRequest request) {
        return batchGet(request, null);
    }

    /**
     * Retrieves a set of <a href="entity:Order">orders</a> by their IDs.
     * <p>If a given order ID does not exist, the ID is ignored instead of generating an error.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<BatchGetOrdersResponse>> batchGet(
            BatchGetOrdersRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders/batch-retrieve")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<BatchGetOrdersResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, BatchGetOrdersResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Enables applications to preview order pricing without creating an order.
     */
    public CompletableFuture<SquareClientHttpResponse<CalculateOrderResponse>> calculate(
            CalculateOrderRequest request) {
        return calculate(request, null);
    }

    /**
     * Enables applications to preview order pricing without creating an order.
     */
    public CompletableFuture<SquareClientHttpResponse<CalculateOrderResponse>> calculate(
            CalculateOrderRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders/calculate")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<CalculateOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, CalculateOrderResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Creates a new order, in the <code>DRAFT</code> state, by duplicating an existing order. The newly created order has
     * only the core fields (such as line items, taxes, and discounts) copied from the original order.
     */
    public CompletableFuture<SquareClientHttpResponse<CloneOrderResponse>> clone(CloneOrderRequest request) {
        return clone(request, null);
    }

    /**
     * Creates a new order, in the <code>DRAFT</code> state, by duplicating an existing order. The newly created order has
     * only the core fields (such as line items, taxes, and discounts) copied from the original order.
     */
    public CompletableFuture<SquareClientHttpResponse<CloneOrderResponse>> clone(
            CloneOrderRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders/clone")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<CloneOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, CloneOrderResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Search all orders for one or more locations. Orders include all sales,
     * returns, and exchanges regardless of how or when they entered the Square
     * ecosystem (such as Point of Sale, Invoices, and Connect APIs).
     * <p><code>SearchOrders</code> requests need to specify which locations to search and define a
     * <a href="entity:SearchOrdersQuery">SearchOrdersQuery</a> object that controls
     * how to sort or filter the results. Your <code>SearchOrdersQuery</code> can:</p>
     * <p>Set filter criteria.
     * Set the sort order.
     * Determine whether to return results as complete <code>Order</code> objects or as
     * <a href="entity:OrderEntry">OrderEntry</a> objects.</p>
     * <p>Note that details for orders processed with Square Point of Sale while in
     * offline mode might not be transmitted to Square for up to 72 hours. Offline
     * orders have a <code>created_at</code> value that reflects the time the order was created,
     * not the time it was subsequently transmitted to Square.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<SearchOrdersResponse>> search() {
        return search(SearchOrdersRequest.builder().build());
    }

    /**
     * Search all orders for one or more locations. Orders include all sales,
     * returns, and exchanges regardless of how or when they entered the Square
     * ecosystem (such as Point of Sale, Invoices, and Connect APIs).
     * <p><code>SearchOrders</code> requests need to specify which locations to search and define a
     * <a href="entity:SearchOrdersQuery">SearchOrdersQuery</a> object that controls
     * how to sort or filter the results. Your <code>SearchOrdersQuery</code> can:</p>
     * <p>Set filter criteria.
     * Set the sort order.
     * Determine whether to return results as complete <code>Order</code> objects or as
     * <a href="entity:OrderEntry">OrderEntry</a> objects.</p>
     * <p>Note that details for orders processed with Square Point of Sale while in
     * offline mode might not be transmitted to Square for up to 72 hours. Offline
     * orders have a <code>created_at</code> value that reflects the time the order was created,
     * not the time it was subsequently transmitted to Square.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<SearchOrdersResponse>> search(RequestOptions requestOptions) {
        return search(SearchOrdersRequest.builder().build(), requestOptions);
    }

    /**
     * Search all orders for one or more locations. Orders include all sales,
     * returns, and exchanges regardless of how or when they entered the Square
     * ecosystem (such as Point of Sale, Invoices, and Connect APIs).
     * <p><code>SearchOrders</code> requests need to specify which locations to search and define a
     * <a href="entity:SearchOrdersQuery">SearchOrdersQuery</a> object that controls
     * how to sort or filter the results. Your <code>SearchOrdersQuery</code> can:</p>
     * <p>Set filter criteria.
     * Set the sort order.
     * Determine whether to return results as complete <code>Order</code> objects or as
     * <a href="entity:OrderEntry">OrderEntry</a> objects.</p>
     * <p>Note that details for orders processed with Square Point of Sale while in
     * offline mode might not be transmitted to Square for up to 72 hours. Offline
     * orders have a <code>created_at</code> value that reflects the time the order was created,
     * not the time it was subsequently transmitted to Square.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<SearchOrdersResponse>> search(SearchOrdersRequest request) {
        return search(request, null);
    }

    /**
     * Search all orders for one or more locations. Orders include all sales,
     * returns, and exchanges regardless of how or when they entered the Square
     * ecosystem (such as Point of Sale, Invoices, and Connect APIs).
     * <p><code>SearchOrders</code> requests need to specify which locations to search and define a
     * <a href="entity:SearchOrdersQuery">SearchOrdersQuery</a> object that controls
     * how to sort or filter the results. Your <code>SearchOrdersQuery</code> can:</p>
     * <p>Set filter criteria.
     * Set the sort order.
     * Determine whether to return results as complete <code>Order</code> objects or as
     * <a href="entity:OrderEntry">OrderEntry</a> objects.</p>
     * <p>Note that details for orders processed with Square Point of Sale while in
     * offline mode might not be transmitted to Square for up to 72 hours. Offline
     * orders have a <code>created_at</code> value that reflects the time the order was created,
     * not the time it was subsequently transmitted to Square.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<SearchOrdersResponse>> search(
            SearchOrdersRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders/search")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<SearchOrdersResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, SearchOrdersResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Retrieves an <a href="entity:Order">Order</a> by ID.
     */
    public CompletableFuture<SquareClientHttpResponse<GetOrderResponse>> get(GetOrdersRequest request) {
        return get(request, null);
    }

    /**
     * Retrieves an <a href="entity:Order">Order</a> by ID.
     */
    public CompletableFuture<SquareClientHttpResponse<GetOrderResponse>> get(
            GetOrdersRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders")
                .addPathSegment(request.getOrderId())
                .build();
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<GetOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, GetOrderResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Updates an open <a href="entity:Order">order</a> by adding, replacing, or deleting
     * fields. Orders with a <code>COMPLETED</code> or <code>CANCELED</code> state cannot be updated.
     * <p>An <code>UpdateOrder</code> request requires the following:</p>
     * <ul>
     * <li>The <code>order_id</code> in the endpoint path, identifying the order to update.</li>
     * <li>The latest <code>version</code> of the order to update.</li>
     * <li>The <a href="https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#sparse-order-objects">sparse order</a>
     * containing only the fields to update and the version to which the update is
     * being applied.</li>
     * <li>If deleting fields, the <a href="https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#identifying-fields-to-delete">dot notation paths</a>
     * identifying the fields to clear.</li>
     * </ul>
     * <p>To pay for an order, see
     * <a href="https://developer.squareup.com/docs/orders-api/pay-for-orders">Pay for Orders</a>.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<UpdateOrderResponse>> update(UpdateOrderRequest request) {
        return update(request, null);
    }

    /**
     * Updates an open <a href="entity:Order">order</a> by adding, replacing, or deleting
     * fields. Orders with a <code>COMPLETED</code> or <code>CANCELED</code> state cannot be updated.
     * <p>An <code>UpdateOrder</code> request requires the following:</p>
     * <ul>
     * <li>The <code>order_id</code> in the endpoint path, identifying the order to update.</li>
     * <li>The latest <code>version</code> of the order to update.</li>
     * <li>The <a href="https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#sparse-order-objects">sparse order</a>
     * containing only the fields to update and the version to which the update is
     * being applied.</li>
     * <li>If deleting fields, the <a href="https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#identifying-fields-to-delete">dot notation paths</a>
     * identifying the fields to clear.</li>
     * </ul>
     * <p>To pay for an order, see
     * <a href="https://developer.squareup.com/docs/orders-api/pay-for-orders">Pay for Orders</a>.</p>
     */
    public CompletableFuture<SquareClientHttpResponse<UpdateOrderResponse>> update(
            UpdateOrderRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders")
                .addPathSegment(request.getOrderId())
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<UpdateOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, UpdateOrderResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Pay for an <a href="entity:Order">order</a> using one or more approved <a href="entity:Payment">payments</a>
     * or settle an order with a total of <code>0</code>.
     * <p>The total of the <code>payment_ids</code> listed in the request must be equal to the order
     * total. Orders with a total amount of <code>0</code> can be marked as paid by specifying an empty
     * array of <code>payment_ids</code> in the request.</p>
     * <p>To be used with <code>PayOrder</code>, a payment must:</p>
     * <ul>
     * <li>Reference the order by specifying the <code>order_id</code> when <a href="api-endpoint:Payments-CreatePayment">creating the payment</a>.
     * Any approved payments that reference the same <code>order_id</code> not specified in the
     * <code>payment_ids</code> is canceled.</li>
     * <li>Be approved with <a href="https://developer.squareup.com/docs/payments-api/take-payments/card-payments/delayed-capture">delayed capture</a>.
     * Using a delayed capture payment with <code>PayOrder</code> completes the approved payment.</li>
     * </ul>
     */
    public CompletableFuture<SquareClientHttpResponse<PayOrderResponse>> pay(PayOrderRequest request) {
        return pay(request, null);
    }

    /**
     * Pay for an <a href="entity:Order">order</a> using one or more approved <a href="entity:Payment">payments</a>
     * or settle an order with a total of <code>0</code>.
     * <p>The total of the <code>payment_ids</code> listed in the request must be equal to the order
     * total. Orders with a total amount of <code>0</code> can be marked as paid by specifying an empty
     * array of <code>payment_ids</code> in the request.</p>
     * <p>To be used with <code>PayOrder</code>, a payment must:</p>
     * <ul>
     * <li>Reference the order by specifying the <code>order_id</code> when <a href="api-endpoint:Payments-CreatePayment">creating the payment</a>.
     * Any approved payments that reference the same <code>order_id</code> not specified in the
     * <code>payment_ids</code> is canceled.</li>
     * <li>Be approved with <a href="https://developer.squareup.com/docs/payments-api/take-payments/card-payments/delayed-capture">delayed capture</a>.
     * Using a delayed capture payment with <code>PayOrder</code> completes the approved payment.</li>
     * </ul>
     */
    public CompletableFuture<SquareClientHttpResponse<PayOrderResponse>> pay(
            PayOrderRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/orders")
                .addPathSegment(request.getOrderId())
                .addPathSegments("pay")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new SquareException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<SquareClientHttpResponse<PayOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new SquareClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, PayOrderResponse.class),
                                response));
                        return;
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new SquareApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new SquareException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
